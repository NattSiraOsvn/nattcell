=== NATT-OS SCAN REPORT ===
Generated: Mon Feb 23 01:05:56 +07 2026

--- 1. ALL TYPES.TS FILES ---
src/core/core/signals/types.ts
src/core/signals/types.ts
src/core/gatekeeper/types.ts
src/core/state/types.ts
src/types.ts
src/governance/gatekeeper/types.ts
src/governance/types.ts

--- 2. FULL CONTENT: src/types.ts ---
// ============================================================
// src/types.ts — NATT-OS Central Type Registry
// Reconstructed by Băng & Kim
// ============================================================

// --- Enums (const objects + types) ---

export const ConstitutionalState = {
  BOOTING: 'BOOTING',
  ACTIVE: 'ACTIVE',
  DEGRADED: 'DEGRADED',
  LOCKDOWN: 'LOCKDOWN',
  MAINTENANCE: 'MAINTENANCE',
} as const;
export type ConstitutionalState = typeof ConstitutionalState[keyof typeof ConstitutionalState];

export const IngestStatus = {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMMITTED: 'COMMITTED',
  FAILED: 'FAILED',
  QUARANTINED: 'QUARANTINED',
  QUEUED: 'QUEUED',
} as const;
export type IngestStatus = typeof IngestStatus[keyof typeof IngestStatus];

export const SyncConflictStrategy = {
  MERGE: 'MERGE',
  SOURCE_WINS: 'SOURCE_WINS',
  DESTINATION_WINS: 'DESTINATION_WINS',
  MANUAL: 'MANUAL',
  CRP: 'CRP',
} as const;
export type SyncConflictStrategy = typeof SyncConflictStrategy[keyof typeof SyncConflictStrategy];

export const AlertLevel = {
  INFO: 'INFO',
  WARNING: 'WARNING',
  CRITICAL: 'CRITICAL',
  EMERGENCY: 'EMERGENCY',
  FATAL: 'FATAL',
} as const;
export type AlertLevel = typeof AlertLevel[keyof typeof AlertLevel];

export const ModuleID = {
  SALES: 'SALES',
  INVENTORY: 'INVENTORY',
  WAREHOUSE: 'WAREHOUSE',
  ACCOUNTING: 'ACCOUNTING',
  HR: 'HR',
  AUDIT: 'AUDIT',
  CUSTOMS: 'CUSTOMS',
  SHOWROOM: 'SHOWROOM',
  ANALYTICS: 'ANALYTICS',
  GOVERNANCE: 'GOVERNANCE',
} as const;
export type ModuleID = typeof ModuleID[keyof typeof ModuleID] | string;

export const PersonaID = {
  THIEN: 'THIEN',
  CAN: 'CAN',
  NA: 'NA',
  BANG: 'BANG',
  BOI_BOI: 'BOI_BOI',
  PHIEU: 'PHIEU',
  KIM: 'KIM',
  KRIS: 'KRIS',
  SYSTEM: 'SYSTEM',
} as const;
export type PersonaID = typeof PersonaID[keyof typeof PersonaID];

export const ViewType = {
  DASHBOARD: 'DASHBOARD',
  SALES: 'SALES',
  INVENTORY: 'INVENTORY',
  WAREHOUSE: 'WAREHOUSE',
  AUDIT: 'AUDIT',
  ANALYTICS: 'ANALYTICS',
  CUSTOMS: 'CUSTOMS',
  SHOWROOM: 'SHOWROOM',
  HR: 'HR',
  SETTINGS: 'SETTINGS',
  GOVERNANCE: 'GOVERNANCE',
  FACTORY: 'FACTORY',
  OMEGA: 'OMEGA',
  sales_terminal: 'sales_terminal',
  chat: 'chat',
  production_manager: 'production_manager',
  sales_tax: 'sales_tax',
  command: 'command',
  monitoring: 'monitoring',
  audit_center: 'audit_center',
} as const;
export type ViewType = typeof ViewType[keyof typeof ViewType];

export const UserRole = {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  SALES_STAFF: 'SALES_STAFF',
  WAREHOUSE_STAFF: 'WAREHOUSE_STAFF',
  ACCOUNTANT: 'ACCOUNTANT',
  AUDITOR: 'AUDITOR',
  VIEWER: 'VIEWER',
  STAFF: 'STAFF',
  SENIOR_STAFF: 'SENIOR_STAFF',
} as const;
export type UserRole = typeof UserRole[keyof typeof UserRole];

export const PositionType = {
  DIRECTOR: 'DIRECTOR',
  MANAGER: 'MANAGER',
  SENIOR_STAFF: 'SENIOR_STAFF',
  STAFF: 'STAFF',
  INTERN: 'INTERN',
  COLLABORATOR: 'COLLABORATOR',
  CHAIRMAN: 'CHAIRMAN',
  CONSULTANT: 'CONSULTANT',
  CFO: 'CFO',
} as const;
export type PositionType = typeof PositionType[keyof typeof PositionType];

export const Department = {
  SALES: 'SALES',
  PRODUCTION: 'PRODUCTION',
  WAREHOUSE: 'WAREHOUSE',
  ACCOUNTING: 'ACCOUNTING',
  HR: 'HR',
  IT: 'IT',
  LEGAL: 'LEGAL',
  HEADQUARTER: 'HEADQUARTER',
} as const;
export type Department = typeof Department[keyof typeof Department];

export const Domain = {
  SALES: 'SALES',
  INVENTORY: 'INVENTORY',
  WAREHOUSE: 'WAREHOUSE',
  ACCOUNTING: 'ACCOUNTING',
  HR: 'HR',
  AUDIT: 'AUDIT',
  GOVERNANCE: 'GOVERNANCE',
  CUSTOMS: 'CUSTOMS',
  PRODUCTION: 'PRODUCTION',
  SHOWROOM: 'SHOWROOM',
  SALES_TAX: 'SALES_TAX',
  LEGAL: 'LEGAL',
  IT: 'IT',
} as const;
export type Domain = typeof Domain[keyof typeof Domain];

export const ApprovalStatus = {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ESCALATED: 'ESCALATED',
} as const;
export type ApprovalStatus = typeof ApprovalStatus[keyof typeof ApprovalStatus];

export const StockStatus = {
  IN_STOCK: 'IN_STOCK',
  LOW_STOCK: 'LOW_STOCK',
  OUT_OF_STOCK: 'OUT_OF_STOCK',
  RESERVED: 'RESERVED',
  AVAILABLE: 'AVAILABLE',
} as const;
export type StockStatus = typeof StockStatus[keyof typeof StockStatus];

export const WarehouseLocation = {
  HCM_HEADQUARTER: 'HCM_HEADQUARTER',
  HN_BRANCH: 'HN_BRANCH',
  MAIN_VAULT: 'MAIN_VAULT',
  SHOWROOM_FLOOR: 'SHOWROOM_FLOOR',
} as const;
export type WarehouseLocation = typeof WarehouseLocation[keyof typeof WarehouseLocation];

export const EInvoiceStatus = {
  DRAFT: 'DRAFT',
  ISSUED: 'ISSUED',
  CANCELLED: 'CANCELLED',
  REPLACED: 'REPLACED',
  XML_BUILT: 'XML_BUILT',
  SIGNED: 'SIGNED',
  ACCEPTED: 'ACCEPTED',
} as const;
export type EInvoiceStatus = typeof EInvoiceStatus[keyof typeof EInvoiceStatus];

export const OrderStatus = {
  DRAFT: 'DRAFT',
  CONFIRMED: 'CONFIRMED',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
} as const;
export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];

export const SalesChannel = {
  IN_STORE: 'IN_STORE',
  REFERRAL: 'REFERRAL',
  ONLINE_INQUIRY: 'ONLINE_INQUIRY',
  EVENT: 'EVENT',
} as const;
export type SalesChannel = typeof SalesChannel[keyof typeof SalesChannel];

export const ProductType = {
  RING: 'RING',
  NECKLACE: 'NECKLACE',
  BRACELET: 'BRACELET',
  EARRING: 'EARRING',
  PENDANT: 'PENDANT',
  CUSTOM: 'CUSTOM',
} as const;
export type ProductType = typeof ProductType[keyof typeof ProductType];

export const PolicyStatus = {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED',
  REVOKED: 'REVOKED',
} as const;
export type PolicyStatus = typeof PolicyStatus[keyof typeof PolicyStatus];

export const PolicyType = {
  INTERNAL: 'INTERNAL',
  REGULATORY: 'REGULATORY',
  CONTRACTUAL: 'CONTRACTUAL',
  OPERATIONAL: 'OPERATIONAL',
} as const;
export type PolicyType = typeof PolicyType[keyof typeof PolicyType];

export const ComplianceRequestType = {
  AUDIT: 'AUDIT',
  CERTIFICATION: 'CERTIFICATION',
  INSPECTION: 'INSPECTION',
  REVIEW: 'REVIEW',
} as const;
export type ComplianceRequestType = typeof ComplianceRequestType[keyof typeof ComplianceRequestType];

export const CertType = {
  ISO: 'ISO',
  KIMBERLEY: 'KIMBERLEY',
  ORIGIN: 'ORIGIN',
  QUALITY: 'QUALITY',
  CUSTOMS: 'CUSTOMS',
} as const;
export type CertType = typeof CertType[keyof typeof CertType];

export const RiskNodeStatus = {
  CLEAR: 'CLEAR',
  FLAGGED: 'FLAGGED',
  BLOCKED: 'BLOCKED',
  UNDER_REVIEW: 'UNDER_REVIEW',
} as const;
export type RiskNodeStatus = typeof RiskNodeStatus[keyof typeof RiskNodeStatus];

export const FinanceStatus = {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
} as const;
export type FinanceStatus = typeof FinanceStatus[keyof typeof FinanceStatus];

export const TrainingStatus = {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  EXPIRED: 'EXPIRED',
} as const;
export type TrainingStatus = typeof TrainingStatus[keyof typeof TrainingStatus];

export const HeatLevel = {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  CRITICAL: 'CRITICAL',
} as const;
export type HeatLevel = typeof HeatLevel[keyof typeof HeatLevel];

export const SealingLevel = {
  NONE: 'NONE',
  SOFT: 'SOFT',
  HARD: 'HARD',
  CONSTITUTIONAL: 'CONSTITUTIONAL',
} as const;
export type SealingLevel = typeof SealingLevel[keyof typeof SealingLevel];

// --- Interfaces (giữ nguyên) ---

export interface BaseEvent<T = unknown> {
  event_id: string;
  event_type: string;
  event_version: string;
  source_cell: string;
  source_module: string;
  actor: { persona?: string; user_id?: string; persona_id?: string };
  domain: string;
  timestamp: number;
  correlation_id: string;
  payload: T;
  audit_required: boolean;
}

export interface Event {
  id: string;
  type: string;
  payload: unknown;
  timestamp: number;
  source: string;
  correlationId?: string;
  tenantId?: string;
}

export interface EventEnvelope {
  event: BaseEvent;
  metadata: EventMetadata;

  payload?: any;
  event_id?: string;
  trace?: any;
}

export interface EventMetadata {
  version: string;
  correlationId: string;
  causationId?: string;
  publishedAt: number;
}

export type EventHandler = (event: BaseEvent) => Promise<void>;

export interface SalesEvent {
  order?: any;
  id: string;
  type: string;
  saleId: string;
  payload: unknown;
  timestamp: number;
}

export interface AuditRecord {
  record_id: string;
  timestamp: string;
  actor: { persona_id: string; user_id: string };
  action: string;
  scope: { cell: string; layer: string };
  payload: unknown;
  integrity_hash?: string;
  tenant_id: string;
  chain_id: string;
  sequence_number: number;
  event_type: string;
  payload_hash: string;
  prev_hash: string;
}

export interface AuditActor {
  persona_id: string;
  user_id: string;
  ip?: string;
}

export interface AuditScope {
  cell: string;
  layer: string;
  domain?: string;
}

export interface AuditChainHead {
  head_hash: string;
  record_count: number;
  last_updated: number;
}

export interface IntegrityState {
  isValid: boolean;
  lastChecked: number;
  violations: string[];
  brokenAt?: string;
}

export interface ActionLog {
  id: string;
  action: string;
  actor: string;
  userId?: string;
  details?: string;
  userPosition?: string;
  module?: string;
  hash?: string;
  timestamp: number;
  result: 'SUCCESS' | 'FAILURE' | 'PENDING';
}

export type GatekeeperDecision = {
  allowed: boolean;
  reason?: string;
  requiresApproval?: boolean;
  escalateTo?: string;
};

export type GatekeeperState = {
  state: ConstitutionalState;
  lockedAt?: number;
  lockedBy?: string;
  reason?: string;
};

export type EmergencyToken = {
  token: string;
  issuedBy: string;
  issuedAt: number;
  expiresAt: number;
  scope: string;
};

export interface StateChange {
  changedAt?: Date | number;
  domain: string;
  entityId: string;
  fromState: string;
  toState: string;
  actor: string;
  userId?: string;
  details?: string;
  userPosition?: string;
  module?: string;
  hash?: string;
  timestamp: number;
  reason?: string;

  tenantId?: string;

  entityType?: string;

  changedBy?: string;
}

export type StateRegistry = {
  [domain: string]: { [entityId: string]: string };
};

export interface Product {
  image?: string;
  id: string;
  name: string;
  sku: string;
  category: string;
  goldType?: string;
  weight?: number;
  price: number;
  status: StockStatus;
  serialNumber?: string;
  images?: string[];
  videos?: string[];
  minOrder?: number;
  moqUnit?: string;
  description?: string;
  stock?: number;
  isCustomizable?: boolean;
  leadTime?: number;
  supplier?: string | { id: string; maNhaCungCap: string; tenNhaCungCap: string; diaChi: string; maSoThue: string; [key: string]: any };
  rating?: number;
  reviews?: number;
  tags?: string[];
  specifications?: Record<string, string>;
  isVerifiedSupplier?: boolean;
  tradeAssurance?: boolean;
}

export interface Movement {
  id: string;
  productId: string;
  type: 'IN' | 'OUT' | 'TRANSFER' | 'ADJUSTMENT';
  quantity: number;
  timestamp: number;
  actor: string;
  userId?: string;
  details?: string;
  userPosition?: string;
  module?: string;
  hash?: string;
  note?: string;
}

export interface Warehouse {
  id: string;
  name: string;
  location: string;
  branch: string;
  capacity: number;
}

export interface WarehouseLocationDetail {
  id: string;
  WAREHOUSEId: string;
  zone: string;
  shelf: string;
  position: string;
}

export interface CustomerLead {
  ownerId?: string;
  id: string;
  name: string;
  phone: string;
  email?: string;
  tier: 'STANDARD' | 'VIP' | 'VVIP';
  source: string;
  assignedTo?: string;
  createdAt: number;

  assignedDate?: number;
}

export interface ApprovalRequest {
  id: string;
  type: string;
  requestedBy: string;
  payload: unknown;
  status: ApprovalStatus;
  createdAt: number;
  resolvedAt?: number;
  resolvedBy?: string;

  changeType?: string;
  recordType?: string;
  reason?: string;
  priority?: string;
}

export interface ApprovalTicket {
  workflowStep?: number;
  requestedAt?: number;
  id: string;
  approvalRequestId: string;
  assignedTo: string;
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  dueAt?: number;

  request?: any;
  approvedBy?: string;
  approvedAt?: number;
  rejectionReason?: string;

  status?: string;

  totalSteps?: number;
}

export interface SyncJob {
  id: string;
  name: string;
  source: string;
  destination: string;
  status: 'IDLE' | 'RUNNING' | 'COMPLETED' | 'FAILED' | 'PAUSED';
  progress: number;
  totalRows: number;
  processedRows: number;
  duplicatesFound: number;
  strategy: SyncConflictStrategy;
  isIncremental: boolean;
  isEncrypted: boolean;
}

export interface SyncLog {
  id: string;
  timestamp: number;
  level: 'INFO' | 'WARNING' | 'ERROR' | 'SECURE' | 'SUCCESS';
  message: string;
}

export type ConflictResolutionMethod = 'CONFIDENCE_BASED' | 'TIMESTAMP_BASED' | 'SOURCE_PRIORITY' | 'MANUAL';

export interface DataPoint {
  id: string;
  source: string;
  payload: unknown;
  confidence: number;
  timestamp: number;
}

export interface FileMetadata {
  context?: any;
  id: string;
  fileName: string;
  fileSize: number;
  mimeType: string;
  uploadedAt: number;
  status: IngestStatus;
  shardId?: string;
  confidence?: number;
  hash?: string;
}

export interface QuantumState {
  energyLevel?: number;
  entanglementCount?: number;
  id: string;
  coherence: number;
  entropy: number;
  superpositionCount: number;
  waveFunction: { amplitude: number; frequency: number; phase: number 
  lastCollapse?: number;
};
  lastCollapse: number;
}

export interface ConsciousnessField {
  focusPoints?: string[];
  awarenessLevel: number;
  mood: 'OPTIMAL' | 'CAUTIOUS' | 'CRITICAL' | 'STABLE';
  lastCollapse: number;
  activeDomains: string[];
}

export interface QuantumEvent {
  probability?: number;
  id: string;
  type: string;
  status: 'SUPERPOSITION' | 'COLLAPSED';
  sensitivityVector: { risk: number; financial: number; temporal: number; operational?: number };
  decision?: string;
  timestamp: number;
}

export interface CustomsDeclaration {
  id: string;
  declarationNumber: string;
  importerName: string;
  exporterName: string;
  items: CustomsDeclarationItem[];
  totalValue: number;
  currency: string;
  status: 'DRAFT' | 'SUBMITTED' | 'UNDER_REVIEW' | 'APPROVED' | 'REJECTED';
  createdAt: number;
}

export interface CustomsDeclarationItem {
  id: string;
  hsCode: string;
  description: string;
  quantity: number;
  unitPrice: number;
  totalValue: number;
  weight: number;
  origin: string;
  riskScore?: number;
}

export interface ActionPlan {
  id: string;
  action: string;
  assignedTo: string;
  priority: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  dueAt?: number;
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED';
}

export interface AccountingEntry {
  status?: string;
  journalType?: string;
  transactionDate?: number;
  id: string;
  type: 'DEBIT' | 'CREDIT';
  amount: number;
  currency: string;
  account: string;
  description: string;
  timestamp: number;
  reference?: unknown;
}

export interface AccountingMappingRule {
  name?: string;
  enabled?: boolean;
  source?: { system: string; [key: string]: unknown };
  destination?: string;
  priority?: number;
  transformation?: (value: unknown, context?: unknown) => unknown;
  autoPost?: boolean;
  destination?: any;
  id: string;
  eventType: string;
  debitAccount: string;
  creditAccount: string;
  description: string;
}

export interface BankTransaction {
  description?: string;
  credit?: boolean;
  id: string;
  amount: number;
  currency: string;
  type: 'DEPOSIT' | 'WITHDRAWAL' | 'TRANSFER';
  timestamp: number;
  reference: string;
  status: 'PENDING' | 'COMPLETED' | 'FAILED';
}

export interface VATEntry {
  id?: string;
  invoiceId?: string;
  category?: string;
  salesValue?: number;
  purchaseValue?: number;
  vatRate?: number;
  taxRate?: number;
  vatAmount?: number;
  taxableAmount?: number;
  addedValue?: number;
  taxAmount?: number;
  timestamp?: number;
}

export interface VATReport {
  period: string;
  totalTaxableAmount?: number;
  totalVATAmount?: number;
  totalAddedValue?: number;
  totalVATPayable?: number;
  accountingStandard?: string;
  formNumber?: string;
  entries: VATEntry[];
}

export interface PITReport {
  employeeId?: string;
  period: string;
  grossIncome?: number;
  taxableIncome?: number;
  pitAmount?: number;
  totalTaxableIncome?: number;
  totalTaxPaid?: number;
  entries?: {
    employeeName: string;
    employeeCode: string;
    taxableIncome: number;
    deductions: number;
    taxPaid: number;
  }[];
}

export interface TaxCalculationResult {
  taxableAmount: number;
  taxRate: number;
  taxAmount: number;
  breakdown: Record<string, number>;
  cit?: {
    taxableIncome: number;
    standardRate: number;
    rate?: number;
    taxAmount: number;
    incentiveAmount: number;
    incentives?: Record<string, number>;
    finalTax: number;
    effectiveRate: number;
  };
}

export interface EInvoice {
  orderId?: string;
  createdAt?: number;
  customerName?: string;
  customerTaxId?: string;
  taxAmount?: number;
  xmlPayload?: string;
  signatureHash?: string;
  taxCode?: string;
  id: string;
  invoiceNumber: string;
  buyer: { name: string; taxCode: string; address: string 
  vatRate?: number;
};
  seller: { name: string; taxCode: string; address: string };
  items: EInvoiceItem[];
  totalAmount: number;
  vatAmount: number;
  status: EInvoiceStatus;
  issuedAt: number;
}

export interface EInvoiceItem {
  id?: string;
  name?: string;
  totalBeforeTax?: number;
  taxRate?: number;
  description: string;
  quantity: number;
  unitPrice: number;
  amount: number;
  vatRate: number;

  goldWeight?: number;
  goldPrice?: number;
  stonePrice?: number;
  laborPrice?: number;
}

export interface EmployeePayroll {
  employeeId: string;
  employeeCode?: string;
  name?: string;
  period: string;
  baseSalary: number;
  allowances: number;
  allowanceLunch?: number;
  deductions: number;
  netSalary: number;
  kpiBonus?: number;
  taxableIncome?: number;
  personalTax?: number;
  status: 'PENDING' | 'APPROVED' | 'PAID';
}

export interface TeamPerformance {
  tasks_in_progress?: number;
  tasks_completed?: number;
  total_tasks?: number;
  teamId: string;
  period: string;
  kpiScore: number;
  revenue: number;
  targets: Record<string, number>;
  actuals: Record<string, number>;

  team_name?: string;

  tasks_blocked?: number;
  load_percentage?: number;
  completion_rate?: number;
}

export interface LaborRuleResult {
  employeeId: string;
  violations: string[];
  recommendations: string[];
  isCompliant: boolean;
}

export interface SellerIdentity {
  id: string;
  name: string;
  role: UserRole;
  branch: string;
  commissionRate: number;
}

export interface SellerReport {
  id?: string;
  sellerId: string;
  period: string;
  totalSales: number;
  totalCommission: number;
  transactionCount: number;

  sellerName?: string;
}

export interface BusinessMetrics {
  revenue: number;
  grossProfit: number;
  netProfit: number;
  period: string;
  branch?: string;
}

export interface GovernanceKPI {
  category?: string;
  kpi_name?: string;
  auditScore: number;
  complianceRate: number;
  riskLevel: AlertLevel;
  period: string;

  kpi_id?: string;

  period_date?: number;
}

export interface HUDMetric {
  id?: string;
  label: string;
  value: number | string;
  unit?: string;
  trend?: 'UP' | 'DOWN' | 'STABLE';
  alert?: AlertLevel;

  name?: string;
}

export interface RealTimeUpdate {
  type: string;
  payload: unknown;
  timestamp: number;
  source: string;
}

export interface ScannerState {
  id: string;
  isActive: boolean;
  lastScan: number;
  tHReatsFound: number;
  status: 'CLEAN' | 'SCANNING' | 'THREAT_DETECTED';
  last_scan_time: number;
  last_scan_head: number;
  errors_found: number;
  is_locked_down: boolean;
  current_status: string;
}

export interface FraudCheckResult {
  level: AlertLevel;
  message: string;
  action: 'PROCEED' | 'BLOCK' | 'WARN' | 'LOCK_ACCOUNT';
  historyRecord?: any;
  transactionId?: string;
  riskScore?: number;
  flags?: string[];
  recommendation?: 'APPROVE' | 'REVIEW' | 'REJECT';

  allowed?: boolean;
}

export interface Certification {
  description?: string;
  id: string;
  type: string;
  issuedBy: string;
  issuedAt: number;
  expiresAt?: number;
  status: 'ACTIVE' | 'VALID' | 'EXPIRED' | 'REVOKED' | 'PENDING' | 'ARCHIVED';

  expiryDate?: number;
  certificateNumber?: string;
  title?: string;
  verificationStatus?: string;

  issuingBody?: number | string;
  createdAt?: number | string;
  updatedAt?: number | string;
}

export interface ModuleConfig {
  title?: string;
  id: ModuleID;
  name: string;
  isEnabled: boolean;
  version: string;
  dependencies: ModuleID[];

  icon?: string;
  group?: string;
  componentName?: string;
  active?: boolean;
}

export interface OperationRecord {
  type?: string;
  error?: string;
  id: string;
  operation: string;
  actor: string;
  userId?: string;
  details?: string;
  userPosition?: string;
  module?: string;
  hash?: string;
  timestamp: number;
  status: 'SUCCESS' | 'FAILURE' | 'PENDING';

  params?: unknown;
}

export interface Checkpoint {
  moduleState?: Record<string, unknown>;
  name?: string;
  state?: unknown;
  isValid?: boolean;
  id: string;
  timestamp: number;
}

export interface DictionaryVersion {
  status?: string;
  version: string;
  publishedAt: number;
  publishedBy: string;
  changeLog: string[];
  id?: string;
  isFrozen?: boolean;
  type?: string;

  versionNumber?: number;
  termsCount?: number;
  dictionaryId?: string;
  data?: any;

  createdAt?: unknown;
  changes?: unknown;
  previousVersionId?: unknown;
}

export interface QuoteRequest {
  id: string;
  productId: string;
  customizations: CustomizationRequest[];
  requestedBy: string;
  createdAt: number;
}

export interface QuoteResult {
  quoteId: string;
  totalPrice: number;
  breakdown: Record<string, number>;
  validUntil: number;
}

export interface CustomizationRequest {
  type: string;
  value: string | number;
  additionalCost?: number;
}

export interface Permission {
  id: string;
  resource: string;
  action: string;
  conditions?: Record<string, unknown>;
}

export type RBACRole = string;
export type RBACPermission = string;

export interface UserPosition {
  userId: string;
  position: PositionType;
  department: Department;
  branch: string;
  startDate: number;
}

export interface PersonaMetadata {
  id?: PersonaID;
  name: string;
  role: string;
  layer?: string;
  isActive?: boolean;
  position?: string;
  bio?: string;
  domain?: string;
  avatar?: string;
}

export const VALID_TRANSITIONS: Record<string, string[]> = {
  DRAFT: ['CONFIRMED', 'CANCELLED'],
  CONFIRMED: ['PROCESSING', 'CANCELLED'],
  PROCESSING: ['READY', 'FAILED'],
  READY: ['COMPLETED', 'CANCELLED'],
  COMPLETED: [],
  CANCELLED: [],
  FAILED: ['PROCESSING'],
};

// --- Sales Core Types ---

export interface OrderItem {
  productId: string;
  serialNumber: string;
  productName: string;
  category?: string;
  goldType?: string;
  weight?: number;
  unitPrice: number;
  costPrice?: number;
  taxRate?: number;
  quantity: number;
  discount?: number;
  depositVND?: number;
}

export interface OrderPricing {
  exchangeRate?: number;
  discountPercentage?: number;
  taxAmount?: number;
  costOfGoods?: number;
  subtotal: number;
  basePriceTotal?: number;
  gdbPriceTotal: number;
  discount: number;
  tax: number;
  totalAmount: number;
  breakdown?: Record<string, number>;
  depositVND?: number;

  promotionDiscount?: number;
}

export interface CommissionInfo {
  policyId: string;
  baseRate: number;
  kpiFactor: number;
  estimatedAmount: number;
  finalAmount: number;
  status: string;
  total: number;
  shell: number;
  stone: number;
}

export interface Customer {
  id: string;
  name: string;
  phone: string;
  email?: string;
  tier: 'STANDARD' | 'VIP' | 'VVIP';
  address?: string;
}

export interface SalesPerson {
  id: string;
  name: string;
  role: UserRole;
  branch: string;
  kpiScore: number;
  position: { role: PositionType };
}

export interface SalesOrder {
  orderId: string;
  orderType: SalesChannel;
  customer: Customer;
  items: OrderItem[];
  pricing: OrderPricing;
  payment: {
    method: string;
    status: string;
    depositAmount: number;
    remainingAmount: number;
    currency: string;
  };
  status: OrderStatus;
  WAREHOUSE: WarehouseLocation;
  salesPerson: SalesPerson;
  commission: CommissionInfo;
  createdAt: number;
  updatedAt: number;
}

// --- Logistics / Payment ---

export interface LogisticsInfo {
  method: string;
  address?: string;
  trackingNumber?: string;
  estimatedDelivery?: number;
  status: string;
}

export interface PaymentInfo {
  method: string;
  status: string;
  depositAmount: number;
  remainingAmount: number;
  currency: string;
  paidAt?: number;
  reference?: string;
}


export interface RuntimeInput {
  spanId?: string;
  identity?: any;
  traceId?: string; operation: string; userId: string; domain: string; tenantId: string; correlationId: string; payload: any; }

export interface RuntimeOutput {
  ok?: boolean;
  metadata?: Record<string, unknown>; success: boolean; data?: any; error?: string; 
  tenantId?: string;

  correlationId?: string;

  trace?: string;
}

export interface RuntimeState {
  lastTick?: number;
  version?: string; status: string; }

export interface TraceContext { spanId: string; traceId: string; }


export interface CostAllocation {
  costCenter: string;
  amount: number;
}

// ============================================================
// TYPES KẾ THỪA TỪ HỆ THỐNG CŨ — APPENDED BY BĂNG 21/02/2026
// ============================================================

export enum InputPersona {
  OFFICE = 'OFFICE (Dân Văn Phòng)',
  DATA_ENTRY = 'DATA_ENTRY (Nhập liệu chuyên nghiệp)',
  PHARMACY = 'PHARMACY (Nhập số thành thuốc)',
  EXPERT = 'EXPERT (Thợ kim hoàn rành tay)',
  ADMIN = 'ADMIN (Anh Natt)'
}

export interface CalibrationData {
  userId: string;
  persona: InputPersona;
  avgCPM: number;
  peakCPM: number;
  errorRate: number;
  burstCapacity: number;
  lastCalibrated: number;
  confidence: number;
}

export interface InputMetrics {
  currentCPM: number;
  keystrokes: number;
  clicks: number;
  intensity: number;
}

export interface EntanglementPair {
  id: string;
  entityA: string;
  entityB: string;
  strength: number;
  type: 'BELL_PAIR' | 'GHZ_STATE';
}

export interface NeuralPulse {
  id: string;
  intensity: number;
  origin: string;
  target: string;
}

export interface QuantumTask {
  id: string;
  type: string;
  payload: any;
  priority: number;
  timestamp: number;
}

export interface DistributedTask {
  id: string;
  origin: string;
  targetModule: string;
  payload: any;
  status: 'PENDING' | 'COMPLETED' | 'FAILED';
  timestamp: number;
  priority?: 'URGENT' | 'NORMAL';
}

export interface PersonnelProfile {
  fullName: string;
  employeeCode: string;
  position: any;
  role: string;
  startDate: string;
  kpiPoints: number;
  tasksCompleted: number;
  lastRating: string;
  bio: string;
}

export interface LearnedTemplate { id: string; name: string; content: string; position?: string; [key: string]: unknown; }

--- 3. WAREHOUSE ENTITY FILES ---

### src/cells/infrastructure/warehouse-cell/value-objects/warehouse-category.registry.ts ###
export const WarehouseCategory = {
  MAIN: 'MAIN',
  BRANCH: 'BRANCH',
  SHOWROOM: 'SHOWROOM',
} as const;
export type WarehouseCategory = typeof WarehouseCategory[keyof typeof WarehouseCategory];

export interface CategoryDefinition {
  code: string;
  name: string;
  defaultUnit: string;
  defaultLocation: string;
  requiresInsurance: boolean;
  isConsumable: boolean;
}

export interface RegisterCategoryCommand {
  code: string;
  name: string;
  defaultUnit: string;
  defaultLocation: string;
  requiresInsurance: boolean;
  isConsumable: boolean;
  createdBy: string;
}

export class WarehouseCategoryRegistry {
  private categories: Map<string, CategoryDefinition> = new Map();

  constructor() {
    // Seed defaults
    this.register({
      code: 'MAIN',
      name: 'Main Vault',
      defaultUnit: 'PIECE',
      defaultLocation: 'VAULT',
      requiresInsurance: true,
      isConsumable: false,
      createdBy: 'system'
    });
    this.register({
      code: 'BRANCH',
      name: 'Branch Storage',
      defaultUnit: 'PIECE',
      defaultLocation: 'BRANCH',
      requiresInsurance: true,
      isConsumable: false,
      createdBy: 'system'
    });
    this.register({
      code: 'SHOWROOM',
      name: 'Showroom Floor',
      defaultUnit: 'PIECE',
      defaultLocation: 'SHOWROOM',
      requiresInsurance: false,
      isConsumable: true,
      createdBy: 'system'
    });
  }

  register(cmd: RegisterCategoryCommand): { success: boolean; error?: string } {
    if (this.categories.has(cmd.code)) {
      return { success: false, error: 'Category already exists' };
    }
    this.categories.set(cmd.code, {
      code: cmd.code,
      name: cmd.name,
      defaultUnit: cmd.defaultUnit,
      defaultLocation: cmd.defaultLocation,
      requiresInsurance: cmd.requiresInsurance,
      isConsumable: cmd.isConsumable,
    });
    return { success: true };
  }

  findByCode(code: string): CategoryDefinition | undefined {
    return this.categories.get(code);
  }

  getActive(): CategoryDefinition[] {
    return Array.from(this.categories.values());
  }
}

export type WarehouseUnit = string;
export type WarehouseLocation = string;

### src/cells/infrastructure/warehouse-cell/interface/index.ts ###
export interface WarehouseInterface {
  // WAREHOUSE-cell ACTIVE — Wave 4
}

### src/cells/infrastructure/warehouse-cell/interface/WarehouseCell.ts ###
/**
 * Warehouse Cell Interface — Public API
 * Cell: WAREHOUSE-cell | Layer: Interface
 *
 * This is the ONLY entry point other cells may reference.
 */
export class WarehouseCell {
  async initialize(): Promise<void> {
    console.log('[WAREHOUSE-cell] Initialized (QUARANTINED)');
  }

  async shutdown(): Promise<void> {
    console.log('[WAREHOUSE-cell] Shutdown');
  }

  getStatus(): string {
    return 'QUARANTINED';
  }
}

### src/cells/infrastructure/warehouse-cell/warehouse-service.ts ###
// Re-export từ application layer
export * from './application/warehouse.service';

### src/cells/infrastructure/warehouse-cell/index.ts ###
export { WarehouseService } from './application/warehouse.service';
export { WarehouseItem } from './domain/entities/warehouse.entity';
export type { WarehouseItemProps } from './domain/entities/warehouse.entity';
export { WarehouseCategoryRegistry } from './domain/value-objects/warehouse-category.registry';

### src/cells/infrastructure/warehouse-cell/application/warehouse.service.ts ###
/**
 * NATT-OS — Warehouse Cell
 * Application Service: WarehouseService
 * Facade cho toàn bộ luồng kho vật tư Tâm Luxury
 *
 * Giao thức mở: người dùng tự thêm danh mục qua RegisterCategoryCommand
 */

import { WarehouseItem } from '../entities/warehouse.entity';
import { WarehouseEngine } from '../services/warehouse.engine';
import { WarehouseDomainService, QAAuditResult } from '../domain/services/WarehouseDomainService';
import {
  WarehouseCategoryRegistry,
  RegisterCategoryCommand,
  CategoryDefinition,
  WarehouseUnit,
  WarehouseLocation,
} from '../value-objects/warehouse-category.registry';
import {
  WarehouseEmittedEvent,
  WarehouseCategoryRegisteredEvent,
  WarehouseItemCreatedEvent,
  WarehouseItemReceivedEvent,
  WarehouseItemReleasedEvent,
  WarehouseItemAdjustedEvent,
  WarehouseStockLowEvent,
  WarehouseStockOutEvent,
  WarehouseInsuranceAlertEvent,
  WarehouseQAAuditCompletedEvent,
} from '../infrastructure/ports/warehouse.contract';

// ═══ COMMAND TYPES ═══

export interface CreateWarehouseItemCommand {
  sku: string;
  name: string;
  categoryCode: string;
  unit?: WarehouseUnit;
  initialQty: number;
  unitCostVND: number;
  location?: WarehouseLocation;
  locationNote?: string;
  minTHReshold?: number;
  supplierId?: string;
  notes?: string;
  createdBy: string;
}

export interface ReceiveStockCommand {
  itemId: string;
  quantity: number;
  unitCostVND: number;
  supplierId?: string;
  notes?: string;
  receivedBy: string;
}

export interface ReleaseStockCommand {
  itemId: string;
  quantity: number;
  reason: string;
  releasedBy: string;
}

export interface AdjustStockCommand {
  itemId: string;
  newQuantity: number;
  reason: string;
  adjustedBy: string;
}

export interface MarkDamagedCommand {
  itemId: string;
  notes: string;
  markedBy: string;
}

export interface UpdateInsuranceCommand {
  itemId: string;
  status: 'COVERED' | 'NOT_COVERED' | 'EXPIRED';
  updatedBy: string;
}

// ═══ SERVICE ═══

export class WarehouseService {
  private items: Map<string, WarehouseItem> = new Map();
  private eventLog: WarehouseEmittedEvent[] = [];

  readonly registry: WarehouseCategoryRegistry;

  constructor() {
    this.registry = new WarehouseCategoryRegistry();  // Seed defaults tự động
  }

  // ═══ GIAO THỨC MỞ — Người dùng tự thêm danh mục ═══

  registerCategory(cmd: RegisterCategoryCommand): {
    success: boolean;
    category?: CategoryDefinition;
    error?: string;
    event?: WarehouseCategoryRegisteredEvent;
  } {
    const result = this.registry.register(cmd);
    if (!result.success) return { success: false, error: result.error };

    const category = this.registry.findByCode(cmd.code)!;
    const event: WarehouseCategoryRegisteredEvent = {
      type: 'WAREHOUSE.category.registered',
      payload: {
        WAREHOUSEId: 'system',
        action: 'register',
        code: category.code,
        name: category.name,
        defaultUnit: category.defaultUnit,
        defaultLocation: category.defaultLocation,
        requiresInsurance: category.requiresInsurance,
        isConsumable: category.isConsumable,
        registeredBy: cmd.createdBy,
        registeredAt: new Date().toISOString(),
      },
    };
    this.eventLog.push(event);
    return { success: true, category, event };
  }

  getCategories(): CategoryDefinition[] {
    return this.registry.getActive();
  }

  // ═══ ITEM MANAGEMENT ═══

  createItem(cmd: CreateWarehouseItemCommand): {
    item?: WarehouseItem;
    errors: string[];
    event?: WarehouseItemCreatedEvent;
  } {
    const errors = WarehouseEngine.validateNewItem(
      cmd.sku, cmd.name, cmd.categoryCode, cmd.initialQty, cmd.unitCostVND, this.registry,
    );
    if (errors.length > 0) return { errors };

    const cat = this.registry.findByCode(cmd.categoryCode)!;
    const id = `WH-${Date.now()}-${Math.random().toString(36).slice(2, 6).toUpperCase()}`;
    const minTHReshold = cmd.minTHReshold ?? WarehouseEngine.suggestMinTHReshold(cmd.categoryCode, this.registry);

    const props = {
      id,
      sku: cmd.sku.toUpperCase().trim(),
      name: cmd.name.trim(),
      categoryCode: cmd.categoryCode.toUpperCase(),
      unit: cmd.unit ?? cat.defaultUnit,
      quantity: cmd.initialQty,
      unitCostVND: cmd.unitCostVND,
      location: cmd.location ?? cat.defaultLocation,
      locationNote: cmd.locationNote,
      minTHReshold,
      supplierId: cmd.supplierId,
      notes: cmd.notes,
      insuranceStatus: cat.requiresInsurance ? 'NOT_COVERED' : 'NOT_COVERED',
      createdAt: new Date(),
      updatedAt: new Date(),
      createdBy: cmd.createdBy,
    };

    const item = new WarehouseItem(props);
    this.items.set(id, item);

    const event: WarehouseItemCreatedEvent = {
      type: 'WAREHOUSE.item.created',
      payload: {
        WAREHOUSEId: id,
        action: 'create',
        itemId: id,
        sku: item.sku,
        name: item.name,
        categoryCode: item.categoryCode,
        initialQty: item.quantity,
        unitCostVND: item.unitCostVND,
        location: item.location,
        minTHReshold: item.minTHReshold,
        createdBy: cmd.createdBy,
        createdAt: new Date().toISOString(),
      },
    };
    this.eventLog.push(event);

    this._checkAndEmitStockAlerts(item);
    return { item, errors: [], event };
  }

  // ─── Nhập kho ───

  receiveStock(cmd: ReceiveStockCommand): {
    item?: WarehouseItem;
    errors: string[];
    event?: WarehouseItemReceivedEvent;
  } {
    const item = this.items.get(cmd.itemId);
    if (!item) return { errors: [`Không tìm thấy mặt hàng: ${cmd.itemId}`] };

    const errors = WarehouseEngine.validateReceive(cmd.quantity);
    if (errors.length > 0) return { errors };

    item.receiveStock(cmd.quantity, cmd.unitCostVND, cmd.receivedBy);

    const event: WarehouseItemReceivedEvent = {
      type: 'WAREHOUSE.item.received',
      payload: {
        WAREHOUSEId: cmd.itemId,
        action: 'receive',
        itemId: item.id,
        quantity: cmd.quantity,
        unitCostVND: cmd.unitCostVND,
        supplierId: cmd.supplierId,
        receivedBy: cmd.receivedBy,
        receivedAt: new Date().toISOString(),
        newAvgCost: item.unitCostVND,
      },
    };
    this.eventLog.push(event);
    this._checkAndEmitStockAlerts(item);
    return { item, errors: [], event };
  }

  // ─── Xuất kho ───

  releaseStock(cmd: ReleaseStockCommand): {
    item?: WarehouseItem;
    errors: string[];
    event?: WarehouseItemReleasedEvent;
  } {
    const item = this.items.get(cmd.itemId);
    if (!item) return { errors: [`Không tìm thấy mặt hàng: ${cmd.itemId}`] };

    const errors = WarehouseEngine.validateRelease(item, cmd.quantity);
    if (errors.length > 0) return { errors };

    item.releaseStock(cmd.quantity, cmd.reason, cmd.releasedBy);

    const event: WarehouseItemReleasedEvent = {
      type: 'WAREHOUSE.item.released',
      payload: {
        WAREHOUSEId: cmd.itemId,
        action: 'release',
        itemId: item.id,
        quantity: cmd.quantity,
        reason: cmd.reason,
        releasedBy: cmd.releasedBy,
        releasedAt: new Date().toISOString(),
        remainingQty: item.quantity,
      },
    };
    this.eventLog.push(event);
    this._checkAndEmitStockAlerts(item);
    return { item, errors: [], event };
  }

  // ─── Kiểm kê / Điều chỉnh ───

  adjustStock(cmd: AdjustStockCommand): {
    item?: WarehouseItem;
    errors: string[];
    event?: WarehouseItemAdjustedEvent;
  } {
    const item = this.items.get(cmd.itemId);
    if (!item) return { errors: [`Không tìm thấy mặt hàng: ${cmd.itemId}`] };
    if (cmd.newQuantity < 0) return { errors: ['Số lượng điều chỉnh không thể âm'] };

    const previousQty = item.quantity;
    item.adjustStock(cmd.newQuantity, cmd.reason, cmd.adjustedBy);

    const event: WarehouseItemAdjustedEvent = {
      type: 'WAREHOUSE.item.adjusted',
      payload: {
        WAREHOUSEId: cmd.itemId,
        action: 'adjust',
        itemId: item.id,
        oldQuantity: previousQty,
        newQuantity: item.quantity,
        reason: cmd.reason,
        adjustedBy: cmd.adjustedBy,
        adjustedAt: new Date().toISOString(),
      },
    };
    this.eventLog.push(event);
    this._checkAndEmitStockAlerts(item);
    return { item, errors: [], event };
  }

  // ─── Đánh dấu hư hỏng ───

  markDamaged(cmd: MarkDamagedCommand): { success: boolean; error?: string } {
    const item = this.items.get(cmd.itemId);
    if (!item) return { success: false, error: `Không tìm thấy mặt hàng: ${cmd.itemId}` };
    item.markDamaged(cmd.notes);
    return { success: true };
  }

  // ─── Cập nhật bảo hiểm ───

  updateInsurance(cmd: UpdateInsuranceCommand): { success: boolean; error?: string } {
    const item = this.items.get(cmd.itemId);
    if (!item) return { success: false, error: `Không tìm thấy mặt hàng: ${cmd.itemId}` };
    item.updateInsurance(cmd.status);
    return { success: true };
  }

  // ═══ ANALYTICS ═══

  runQAAudit(auditedBy: string): QAAuditResult & { event: WarehouseQAAuditCompletedEvent } {
    const allItems = Array.from(this.items.values());
    const result = WarehouseDomainService.runQAAudit(allItems);

    result.insuranceAlerts.forEach(alert => {
      const ev: WarehouseInsuranceAlertEvent = {
        type: 'WAREHOUSE.insurance.alert',
        payload: {
          WAREHOUSEId: alert.itemId,
          action: 'alert',
          itemId: alert.itemId,
          sku: alert.sku,
          status: alert.insuranceStatus,
        },
      };
      this.eventLog.push(ev);
    });

    const event: WarehouseQAAuditCompletedEvent = {
      type: 'WAREHOUSE.qa.audit.completed',
      payload: {
        WAREHOUSEId: 'system',
        action: 'audit',
        healthScore: result.healthScore,
        totalItems: result.totalItems,
        totalValueVND: result.totalValueVND,
        stockAlertCount: result.stockAlerts.length,
        insuranceAlertCount: result.insuranceAlerts.length,
        unregisteredCategoryCount: result.unregisteredCategories.length,
        auditedBy,
        auditedAt: new Date().toISOString(),
      },
    };
    this.eventLog.push(event);
    return { ...result, event };
  }

  getDailyReceipts(date: Date): WarehouseItem[] {
    return Array.from(this.items.values()).filter(item =>
      item.movements.some(m =>
        m.type === 'IN' &&
        m.timestamp.toDateString() === date.toDateString()
      )
    );
  }

  getItemsByCategory(categoryCode: string): WarehouseItem[] {
    return Array.from(this.items.values())
      .filter(i => i.categoryCode === categoryCode.toUpperCase());
  }

  getItemsByLocation(location: WarehouseLocation): WarehouseItem[] {
    return Array.from(this.items.values()).filter(i => i.location === location);
  }

  getLowStockItems(): WarehouseItem[] {
    return Array.from(this.items.values()).filter(i => i.isLowStock() || i.isOutOfStock());
  }

  getInsuranceRequired(): WarehouseItem[] {
    return Array.from(this.items.values()).filter(i =>
      WarehouseDomainService.requiresInsurance(i.categoryCode) && i.insuranceStatus !== 'COVERED'
    );
  }

  findBySku(sku: string): WarehouseItem | null {
    return Array.from(this.items.values()).find(i => i.sku === sku.toUpperCase()) ?? null;
  }

  findById(id: string): WarehouseItem | null {
    return this.items.get(id) ?? null;
  }

  getEventLog(): WarehouseEmittedEvent[] {
    return [...this.eventLog];
  }

  private _checkAndEmitStockAlerts(item: WarehouseItem): void {
    if (item.isOutOfStock()) {
      const ev: WarehouseStockOutEvent = {
        type: 'WAREHOUSE.stock.out',
        payload: {
          WAREHOUSEId: item.id,
          action: 'alert',
          itemId: item.id,
          sku: item.sku,
        },
      };
      this.eventLog.push(ev);
    } else if (item.isLowStock()) {
      const ev: WarehouseStockLowEvent = {
        type: 'WAREHOUSE.stock.low',
        payload: {
          WAREHOUSEId: item.id,
          action: 'alert',
          itemId: item.id,
          sku: item.sku,
          currentQty: item.quantity,
          tHReshold: item.minTHReshold,
        },
      };
      this.eventLog.push(ev);
    }
  }
}


// WarehouseProvider - compatibility alias
export class WarehouseProvider {
  static getAllInventory(): unknown[] { return []; }
  private static service = new WarehouseService();
  
  static getInstance() { return this.service; }
  
  static async getItems() {
    return this.service.getAllItems ? this.service.getAllItems() : [];
  }
}

### src/cells/infrastructure/warehouse-cell/application/use-cases/ReleaseGoods.ts ###
import { IWarehouseRepository } from '../../ports/WarehouseRepository';

export class ReleaseGoods {
  constructor(private readonly repo: IWarehouseRepository) {}

  async execute(id: string, quantity: number, reason: string, releasedBy: string): Promise<boolean> {
    const item = await this.repo.findById(id);
    if (!item || item.quantity < quantity) return false;
    item.releaseStock(quantity, reason, releasedBy);
    await this.repo.save(item);
    return true;
  }
}

### src/cells/infrastructure/warehouse-cell/application/use-cases/ReceiveGoods.ts ###
/**
 * ReceiveGoods Use Case
 * Cell: WAREHOUSE-cell | Layer: Application
 */
import { IWarehouseRepository } from '../../ports/WarehouseRepository';
import { WarehouseItem } from '../../domain/entities/WarehouseEntity';

export class ReceiveGoods {
  constructor(private readonly repo: IWarehouseRepository) {}

  async execute(item: WarehouseItem): Promise<void> {
    await this.repo.save(item);
  }
}

### src/cells/infrastructure/warehouse-cell/application/services/WarehouseApplicationService.ts ###
/**
 * Warehouse Application Service
 * Cell: WAREHOUSE-cell | Layer: Application
 */
import { ReceiveGoods } from '../use-cases/ReceiveGoods';
import { ReleaseGoods } from '../use-cases/ReleaseGoods';

export class WarehouseApplicationService {
  constructor(
    private readonly receiveGoods: ReceiveGoods,
    private readonly releaseGoods: ReleaseGoods
  ) {}
}

### src/cells/infrastructure/warehouse-cell/infrastructure/repositories/InMemoryWarehouseRepository.ts ###
/**
 * InMemory Warehouse Repository
 * Cell: WAREHOUSE-cell | Layer: Infrastructure
 */
import { IWarehouseRepository } from '../../ports/WarehouseRepository';
import { WarehouseItem } from '../../domain/entities/WarehouseEntity';

export class InMemoryWarehouseRepository implements IWarehouseRepository {
  private store: Map<string, WarehouseItem> = new Map();

  async findById(id: string): Promise<WarehouseItem | null> {
    return this.store.get(id) || null;
  }

  async save(item: WarehouseItem): Promise<void> {
    this.store.set(item.id, item);
  }

  async delete(id: string): Promise<boolean> {
    return this.store.delete(id);
  }

  async findByCategory(cat: string): Promise<WarehouseItem[]> {
    return [...this.store.values()].filter(i => i.category === cat);
  }
}

### src/cells/infrastructure/warehouse-cell/infrastructure/adapters/WarehouseEventAdapter.ts ###
/**
 * Warehouse Event Adapter
 * Cell: WAREHOUSE-cell | Layer: Infrastructure
 */
export class WarehouseEventAdapter {
  async emit(eventType: string, payload: Record<string, unknown>): Promise<void> {
    console.log(`[WAREHOUSE-cell] Event: ${eventType}`, payload);
  }
}

### src/cells/infrastructure/warehouse-cell/infrastructure/ports/warehouse.contract.ts ###
export const WAREHOUSE_CONTRACT = {
  cellId: 'WAREHOUSE-cell',
  version: '2.1.0',
  emits: [
    'WAREHOUSE.category.registered',
    'WAREHOUSE.item.created',
    'WAREHOUSE.item.received',
    'WAREHOUSE.item.released',
    'WAREHOUSE.item.adjusted',
    'WAREHOUSE.item.damaged',
    'WAREHOUSE.stock.low',
    'WAREHOUSE.stock.out',
    'WAREHOUSE.insurance.alert',
    'WAREHOUSE.qa.audit.completed',
  ],
  consumes: [
    'order.created',
    'inventory.item.transferred',
  ],
} as const;

export interface WarehouseCategoryRegisteredEvent {
  type: 'WAREHOUSE.category.registered';
  payload: { WAREHOUSEId: string; action: string; code: string; name: string; defaultUnit: string; defaultLocation: string; requiresInsurance: boolean; isConsumable: boolean; registeredBy: string; registeredAt: string; };
}
export interface WarehouseItemCreatedEvent {
  type: 'WAREHOUSE.item.created';
  payload: { WAREHOUSEId: string; action: string; itemId: string; sku: string; name: string; categoryCode: string; initialQty: number; unitCostVND: number; location: string; minTHReshold: number; createdBy: string; createdAt: string; };
}
export interface WarehouseItemReceivedEvent {
  type: 'WAREHOUSE.item.received';
  payload: { WAREHOUSEId: string; action: string; itemId: string; quantity: number; unitCostVND: number; supplierId?: string; receivedBy: string; receivedAt: string; newAvgCost: number; };
}
export interface WarehouseItemReleasedEvent {
  type: 'WAREHOUSE.item.released';
  payload: { WAREHOUSEId: string; action: string; itemId: string; quantity: number; reason: string; releasedBy: string; releasedAt: string; remainingQty: number; };
}
export interface WarehouseItemAdjustedEvent {
  type: 'WAREHOUSE.item.adjusted';
  payload: { WAREHOUSEId: string; action: string; itemId: string; oldQuantity: number; newQuantity: number; reason: string; adjustedBy: string; adjustedAt: string; };
}
export interface WarehouseStockLowEvent {
  type: 'WAREHOUSE.stock.low';
  payload: { WAREHOUSEId: string; action: string; itemId: string; sku: string; currentQty: number; tHReshold: number; };
}
export interface WarehouseStockOutEvent {
  type: 'WAREHOUSE.stock.out';
  payload: { WAREHOUSEId: string; action: string; itemId: string; sku: string; };
}
export interface WarehouseInsuranceAlertEvent {
  type: 'WAREHOUSE.insurance.alert';
  payload: { WAREHOUSEId: string; action: string; itemId: string; sku: string; status: string; };
}
export interface WarehouseQAAuditCompletedEvent {
  type: 'WAREHOUSE.qa.audit.completed';
  payload: { WAREHOUSEId: string; action: string; healthScore: number; totalItems: number; totalValueVND: number; stockAlertCount: number; insuranceAlertCount: number; unregisteredCategoryCount: number; auditedBy: string; auditedAt: string; };
}
export type WarehouseEmittedEvent =
  | WarehouseCategoryRegisteredEvent | WarehouseItemCreatedEvent
  | WarehouseItemReceivedEvent | WarehouseItemReleasedEvent
  | WarehouseItemAdjustedEvent | WarehouseStockLowEvent
  | WarehouseStockOutEvent | WarehouseInsuranceAlertEvent
  | WarehouseQAAuditCompletedEvent;

### src/cells/infrastructure/warehouse-cell/ports/WarehouseEventEmitter.ts ###
/**
 * Warehouse Event Emitter Port
 * Cell: WAREHOUSE-cell | Layer: Ports
 */
export interface IWarehouseEventEmitter {
  emit(eventType: string, payload: Record<string, unknown>): Promise<void>;
}

### src/cells/infrastructure/warehouse-cell/ports/WarehouseRepository.ts ###
/**
 * Warehouse Repository Port
 * Cell: WAREHOUSE-cell | Layer: Ports
 */
import { WarehouseItem } from '../domain/entities/WarehouseEntity';

export interface IWarehouseRepository {
  findById(id: string): Promise<WarehouseItem | null>;
  save(item: WarehouseItem): Promise<void>;
  delete(id: string): Promise<boolean>;
  findByCategory(category: string): Promise<WarehouseItem[]>;
}

### src/cells/infrastructure/warehouse-cell/ports/index.ts ###
export * from './warehouse.contract';

### src/cells/infrastructure/warehouse-cell/ports/warehouse.contract.ts ###
/**
 * NATT-OS WAREHOUSE CELL - EDA CONTRACT
 */
export const WAREHOUSE_CONTRACT = {
  cellId: 'WAREHOUSE-cell',
  emits: ['WAREHOUSE.goods.received', 'WAREHOUSE.goods.released', 'WAREHOUSE.inventory.updated'],
  consumes: ['order.created', 'production.completed']
} as const;

### src/cells/infrastructure/warehouse-cell/domain/value-objects/warehouse-category.registry.ts ###
/**
 * NATT-OS — Warehouse Cell
 * Value Object: WarehouseCategoryRegistry
 * Giao thức kho mở — người dùng tự thêm hạng mục
 *
 * Pattern: Open Registry — không hardcode enum,
 * seed defaults từ thực tế Tâm Luxury, mở rộng qua register()
 */

// ═══ TYPES ═══

export type WarehouseUnit =
  | 'GR' | 'KG'           // Khối lượng — vàng, hóa chất
  | 'VIEN'                // Viên — đá, kim cương rời
  | 'CAI' | 'BO'          // Đếm đơn/bộ
  | 'MUI'                 // Mũi khoan
  | 'CAN' | 'CHAI' | 'LIT' // Lỏng — hóa chất
  | 'BICH' | 'TAM'        // Gói/tấm
  | 'CAY' | 'MIENG' | 'CON' // Cây/miếng/con
  | 'CUSTOM';             // Đơn vị tự định nghĩa

export type WarehouseLocation =
  | 'KHO_MUI'
  | 'KHO_HOP'
  | 'KHO_HOA_CHAT'
  | 'KHO_VAT_TU'
  | 'KHO_NGUYEN_LIEU'     // Vàng thỏi, kim cương rời
  | 'KHO_BAN_THANH_PHAM'  // Vỏ chưa gắn đá
  | 'KHO_KHAC';           // Kho tùy chỉnh

export interface CategoryDefinition {
  code: string;                      // Mã danh mục — unique key
  name: string;                      // Tên hiển thị
  description?: string;
  defaultUnit: WarehouseUnit;        // ĐVT mặc định
  defaultLocation: WarehouseLocation; // Vị trí kho mặc định
  requiresInsurance: boolean;        // Cần bảo hiểm? (vàng, kim cương)
  isConsumable: boolean;             // Tiêu hao (hóa chất, vật tư) hay tài sản cố định (máy móc)
  minStockAlert?: number;            // Cảnh báo tồn kho tối thiểu
  isActive: boolean;
  createdAt: Date;
  createdBy: string;
}

export interface RegisterCategoryCommand {
  code: string;
  name: string;
  description?: string;
  defaultUnit: WarehouseUnit;
  defaultLocation: WarehouseLocation;
  requiresInsurance?: boolean;
  isConsumable?: boolean;
  minStockAlert?: number;
  createdBy: string;
}

// ═══ SEED DEFAULTS — Từ thực tế Sổ Kho Tâm Luxury ═══

export const DEFAULT_CATEGORIES: RegisterCategoryCommand[] = [
  {
    code: 'CONG_CU_CO_DINH',
    name: 'Công cụ cố định',
    description: 'Máy strong, máy treo, kính hiển vi, thước đo — tài sản giao theo người',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_VAT_TU',
    requiresInsurance: false,
    isConsumable: false,
    minStockAlert: 1,
    createdBy: 'SYSTEM',
  },
  {
    code: 'CONG_CU_TIEU_HAO',
    name: 'Công cụ tiêu hao',
    description: 'Mũi khoan, đĩa xoàn, kềm, dũa Thụy Sĩ — mòn theo sử dụng',
    defaultUnit: 'MUI',
    defaultLocation: 'KHO_MUI',
    requiresInsurance: false,
    isConsumable: true,
    minStockAlert: 10,
    createdBy: 'SYSTEM',
  },
  {
    code: 'VAT_TU_SAN_XUAT',
    name: 'Vật tư sản xuất',
    description: 'Thạch cao, thuốc hàn, láp đúc, mẻ đất — dùng trong gia công',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_VAT_TU',
    requiresInsurance: false,
    isConsumable: true,
    minStockAlert: 5,
    createdBy: 'SYSTEM',
  },
  {
    code: 'HOA_CHAT',
    name: 'Hóa chất',
    description: 'Axit đen, nước cất, bột run, metalor RH, resin, bột siêu âm',
    defaultUnit: 'LIT',
    defaultLocation: 'KHO_HOA_CHAT',
    requiresInsurance: false,
    isConsumable: true,
    minStockAlert: 2,
    createdBy: 'SYSTEM',
  },
  {
    code: 'HOP_DONG_GOI',
    name: 'Hộp đóng gói sản phẩm',
    description: 'Hộp nhẫn mới/cũ, hộp vòng, hộp lắc, hộp mặt dây, hộp bộ Tâm',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_HOP',
    requiresInsurance: false,
    isConsumable: true,
    minStockAlert: 50,
    createdBy: 'SYSTEM',
  },
  {
    code: 'BAO_BI_DONG_GOI',
    name: 'Bao bì đóng gói',
    description: 'Túi zip các cỡ, túi giấy, bìa da cá sấu, ribbon, xâu nịt nhựa',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_HOP',
    requiresInsurance: false,
    isConsumable: true,
    minStockAlert: 100,
    createdBy: 'SYSTEM',
  },
  {
    code: 'VAN_PHONG_PHAM',
    name: 'Văn phòng phẩm & thiết bị',
    description: 'Thẻ nhớ, chuột máy tính, bìa lò xo, áo thun đồng phục',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_VAT_TU',
    requiresInsurance: false,
    isConsumable: false,
    createdBy: 'SYSTEM',
  },
  {
    code: 'NGUYEN_LIEU_QUY',
    name: 'Nguyên liệu quý',
    description: 'Vàng thỏi, vàng nhẫn SBJ, kim tấm, viên chủ, đá phụ rời',
    defaultUnit: 'GR',
    defaultLocation: 'KHO_NGUYEN_LIEU',
    requiresInsurance: true,   // ← BẮT BUỘC bảo hiểm
    isConsumable: true,
    minStockAlert: 100,        // gram
    createdBy: 'SYSTEM',
  },
  {
    code: 'BAN_THANH_PHAM',
    name: 'Bán thành phẩm',
    description: 'Vỏ nhẫn chưa gắn đá, dây chuyền chưa gắn mặt, WIP',
    defaultUnit: 'CAI',
    defaultLocation: 'KHO_BAN_THANH_PHAM',
    requiresInsurance: false,
    isConsumable: false,
    minStockAlert: 5,
    createdBy: 'SYSTEM',
  },
];

// ═══ REGISTRY ═══

export class WarehouseCategoryRegistry {
  private categories: Map<string, CategoryDefinition> = new Map();

  constructor() {
    // Seed defaults khi khởi tạo
    for (const cmd of DEFAULT_CATEGORIES) {
      this._registerInternal(cmd);
    }
  }

  // ─── Register ───

  register(cmd: RegisterCategoryCommand): { success: boolean; error?: string } {
    const code = cmd.code.toUpperCase().trim();
    if (!code) return { success: false, error: 'Mã danh mục không được để trống' };
    if (this.categories.has(code)) return { success: false, error: `Mã ${code} đã tồn tại` };
    if (!cmd.name?.trim()) return { success: false, error: 'Tên danh mục không được để trống' };

    this._registerInternal({ ...cmd, code });
    return { success: true };
  }

  private _registerInternal(cmd: RegisterCategoryCommand): void {
    const def: CategoryDefinition = {
      code: cmd.code.toUpperCase(),
      name: cmd.name,
      description: cmd.description,
      defaultUnit: cmd.defaultUnit,
      defaultLocation: cmd.defaultLocation,
      requiresInsurance: cmd.requiresInsurance ?? false,
      isConsumable: cmd.isConsumable ?? true,
      minStockAlert: cmd.minStockAlert,
      isActive: true,
      createdAt: new Date(),
      createdBy: cmd.createdBy,
    };
    this.categories.set(def.code, def);
  }

  // ─── Update ───

  deactivate(code: string): boolean {
    const cat = this.categories.get(code.toUpperCase());
    if (!cat) return false;
    this.categories.set(code.toUpperCase(), { ...cat, isActive: false });
    return true;
  }

  updateMinStock(code: string, minStock: number): boolean {
    const cat = this.categories.get(code.toUpperCase());
    if (!cat) return false;
    this.categories.set(code.toUpperCase(), { ...cat, minStockAlert: minStock });
    return true;
  }

  // ─── Queries ───

  findByCode(code: string): CategoryDefinition | null {
    return this.categories.get(code.toUpperCase()) ?? null;
  }

  getAll(): CategoryDefinition[] {
    return Array.from(this.categories.values());
  }

  getActive(): CategoryDefinition[] {
    return this.getAll().filter(c => c.isActive);
  }

  getInsuranceRequired(): CategoryDefinition[] {
    return this.getActive().filter(c => c.requiresInsurance);
  }

  exists(code: string): boolean {
    return this.categories.has(code.toUpperCase());
  }
}

// Singleton — dùng chung toàn cell
export const WAREHOUSECategoryRegistry = new WarehouseCategoryRegistry();

### src/cells/infrastructure/warehouse-cell/domain/services/warehouse-domain.service.ts ###
/**
 * NATT-OS — Warehouse Cell
 * Domain Service: WarehouseDomainService
 */

import { WarehouseItem } from '../entities/warehouse.entity';
import { WarehouseCategoryRegistry } from '../value-objects/warehouse-category.registry';

export interface StockAlert {
  itemId: string;
  sku: string;
  name: string;
  categoryCode: string;
  currentQty: number;
  minTHReshold: number;
  severity: 'OUT_OF_STOCK' | 'LOW_STOCK';
}

export interface InsuranceAlert {
  itemId: string;
  sku: string;
  name: string;
  totalValueVND: number;
  insuranceStatus: string;
}

export interface QAAuditResult {
  healthScore: number;               // 0-100
  totalItems: number;
  totalValueVND: number;
  stockAlerts: StockAlert[];
  insuranceAlerts: InsuranceAlert[];
  unregisteredCategories: string[];  // Category codes không có trong registry
}

export class WarehouseDomainService {
  constructor(private readonly registry: WarehouseCategoryRegistry) {}

  // ─── Validation ───

  validateItem(item: WarehouseItem): string[] {
    const errors: string[] = [];
    if (!item.sku?.trim()) errors.push('SKU không được để trống');
    if (!item.name?.trim()) errors.push('Tên mặt hàng không được để trống');
    if (item.quantity < 0) errors.push('Số lượng không thể âm');
    if (item.unitCostVND < 0) errors.push('Đơn giá không thể âm');
    if (!this.registry.exists(item.categoryCode))
      errors.push(`Danh mục ${item.categoryCode} chưa đăng ký trong registry`);
    return errors;
  }

  canRelease(item: WarehouseItem, quantity: number): boolean {
    return item.quantity >= quantity && item.status !== 'DAMAGED' && item.status !== 'DISCONTINUED';
  }

  // ─── Stock alerts ───

  getStockAlerts(items: WarehouseItem[]): StockAlert[] {
    return items
      .filter(i => i.isOutOfStock() || i.isLowStock())
      .map(i => ({
        itemId: i.id,
        sku: i.sku,
        name: i.name,
        categoryCode: i.categoryCode,
        currentQty: i.quantity,
        minTHReshold: i.minTHReshold,
        severity: i.isOutOfStock() ? 'OUT_OF_STOCK' : 'LOW_STOCK',
      }));
  }

  // ─── Insurance audit ───

  getInsuranceAlerts(items: WarehouseItem[]): InsuranceAlert[] {
    return items.filter(i => {
      const cat = this.registry.findByCode(i.categoryCode);
      return cat?.requiresInsurance && i.insuranceStatus !== 'COVERED';
    }).map(i => ({
      itemId: i.id,
      sku: i.sku,
      name: i.name,
      totalValueVND: i.totalValueVND,
      insuranceStatus: i.insuranceStatus,
    }));
  }

  // ─── QA Audit — từ v2 WarehouseEngine.runQAAudit() ───

  runQAAudit(items: WarehouseItem[]): QAAuditResult {
    const stockAlerts = this.getStockAlerts(items);
    const insuranceAlerts = this.getInsuranceAlerts(items);

    const unregisteredCategories = [...new Set(
      items
        .filter(i => !this.registry.exists(i.categoryCode))
        .map(i => i.categoryCode)
    )];

    const totalValueVND = items.reduce((sum, i) => sum + i.totalValueVND, 0);

    // Health score: -10 mỗi OUT_OF_STOCK, -5 mỗi LOW_STOCK, -15 mỗi insurance alert
    const deductions =
      stockAlerts.filter(a => a.severity === 'OUT_OF_STOCK').length * 10 +
      stockAlerts.filter(a => a.severity === 'LOW_STOCK').length * 5 +
      insuranceAlerts.length * 15 +
      unregisteredCategories.length * 5;

    const healthScore = Math.max(0, 100 - deductions);

    return {
      healthScore,
      totalItems: items.length,
      totalValueVND,
      stockAlerts,
      insuranceAlerts,
      unregisteredCategories,
    };
  }

  // ─── Category helpers ───

  getSuggestedUnit(categoryCode: string): string {
    return this.registry.findByCode(categoryCode)?.defaultUnit ?? 'CAI';
  }

  getSuggestedLocation(categoryCode: string): string {
    return this.registry.findByCode(categoryCode)?.defaultLocation ?? 'KHO_VAT_TU';
  }

  requiresInsurance(categoryCode: string): boolean {
    return this.registry.findByCode(categoryCode)?.requiresInsurance ?? false;
  }
}

### src/cells/infrastructure/warehouse-cell/domain/services/WarehouseDomainService.ts ###
export type QAAuditResult = {
  healthScore: number;
  totalItems: number;
  totalValueVND: number;
  stockAlerts: any[];
  insuranceAlerts: any[];
  unregisteredCategories: any[];
};

export class WarehouseDomainService {
  static runQAAudit(items: any[]): QAAuditResult {
    // Implement logic thật
    return {
      healthScore: 0.95,
      totalItems: items.length,
      totalValueVND: items.reduce((sum, i) => sum + i.quantity * i.unitCostVND, 0),
      stockAlerts: [],
      insuranceAlerts: [],
      unregisteredCategories: [],
    };
  }

  static requiresInsurance(categoryCode: string): boolean {
    return categoryCode === 'MAIN' || categoryCode === 'BRANCH';
  }
}

### src/cells/infrastructure/warehouse-cell/domain/services/warehouse.engine.ts ###
/**
 * NATT-OS — Warehouse Cell
 * Domain Engine: WarehouseEngine
 * Pure business rules — không có side effects
 */

import { WarehouseItem } from '../entities/warehouse.entity';
import { WarehouseCategoryRegistry } from '../value-objects/warehouse-category.registry';

export class WarehouseEngine {

  // ─── Validation ───

  static validateNewItem(
    sku: string,
    name: string,
    categoryCode: string,
    quantity: number,
    unitCostVND: number,
    registry: WarehouseCategoryRegistry,
  ): string[] {
    const errors: string[] = [];
    if (!sku?.trim()) errors.push('SKU không được để trống');
    if (!name?.trim()) errors.push('Tên mặt hàng không được để trống');
    if (!categoryCode?.trim()) errors.push('Danh mục không được để trống');
    if (!registry.exists(categoryCode))
      errors.push(`Danh mục "${categoryCode}" chưa đăng ký — dùng RegisterCategoryCommand trước`);
    if (quantity < 0) errors.push('Số lượng ban đầu không thể âm');
    if (unitCostVND < 0) errors.push('Đơn giá không thể âm');
    return errors;
  }

  static validateReceive(quantity: number, unitCost: number): string[] {
    const errors: string[] = [];
    if (quantity <= 0) errors.push('Số lượng nhập phải lớn hơn 0');
    if (unitCost < 0) errors.push('Đơn giá không thể âm');
    return errors;
  }

  static validateRelease(item: WarehouseItem, quantity: number): string[] {
    const errors: string[] = [];
    if (quantity <= 0) errors.push('Số lượng xuất phải lớn hơn 0');
    if (quantity > item.quantity) errors.push(`Tồn kho không đủ: có ${item.quantity}, yêu cầu ${quantity}`);
    if (item.status === 'DAMAGED') errors.push('Mặt hàng đang bị hư hỏng — không thể xuất');
    if (item.status === 'DISCONTINUED') errors.push('Mặt hàng đã ngưng sử dụng');
    return errors;
  }

  // ─── Category auto-suggest ───

  static suggestMinTHReshold(categoryCode: string, registry: WarehouseCategoryRegistry): number {
    const cat = registry.findByCode(categoryCode);
    return cat?.minStockAlert ?? 5;
  }

  static suggestInsuranceStatus(
    categoryCode: string,
    registry: WarehouseCategoryRegistry,
  ): 'COVERED' | 'NOT_COVERED' {
    const cat = registry.findByCode(categoryCode);
    // Nguyên liệu quý → cần bảo hiểm → default NOT_COVERED (để admin bổ sung)
    return cat?.requiresInsurance ? 'NOT_COVERED' : 'NOT_COVERED';
  }

  // ─── Stock status logic ───

  static computeStatus(quantity: number, minTHReshold: number): WarehouseItem['status'] {
    if (quantity === 0) return 'OUT_OF_STOCK';
    if (quantity <= minTHReshold) return 'LOW_STOCK';
    return 'AVAILABLE';
  }

  // ─── Weighted average cost ───

  static computeNewAvgCost(
    currentQty: number,
    currentCost: number,
    incomingQty: number,
    incomingCost: number,
  ): number {
    const total = currentQty + incomingQty;
    if (total === 0) return 0;
    return Math.round((currentQty * currentCost + incomingQty * incomingCost) / total);
  }
}

### src/cells/infrastructure/warehouse-cell/domain/entities/warehouse.entity.ts ###
/**
 * NATT-OS — Warehouse Cell
 * Entity: WarehouseItem
 * Quản lý vật tư, nguyên liệu, công cụ kho Tâm Luxury
 */

import { WarehouseUnit, WarehouseLocation } from '../value-objects/warehouse-category.registry';

export type WarehouseItemStatus =
  | 'AVAILABLE'     // Sẵn sàng sử dụng
  | 'LOW_STOCK'     // Sắp hết — dưới minTHReshold
  | 'OUT_OF_STOCK'  // Hết hàng
  | 'RESERVED'      // Đã đặt trước
  | 'DAMAGED'       // Hư hỏng
  | 'DISCONTINUED'; // Ngưng sử dụng

export interface WarehouseItemProps {
  id: string;
  sku: string;
  name: string;
  categoryCode: string;          // Ref → WarehouseCategoryRegistry
  unit: WarehouseUnit;
  quantity: number;
  unitCostVND: number;           // Đơn giá bình quân
  location: WarehouseLocation;
  locationNote?: string;         // VD: "Két A1 - Tầng 1"
  status: WarehouseItemStatus;
  minTHReshold: number;          // Ngưỡng cảnh báo tồn kho
  insuranceStatus: 'COVERED' | 'NOT_COVERED' | 'EXPIRED';
  supplierId?: string;
  lastCountDate?: Date;
  notes?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface MovementRecord {
  type: 'IN' | 'OUT' | 'TRANSFER' | 'ADJUST';
  quantity: number;
  reason: string;
  performedBy: string;
  fromLocation?: WarehouseLocation;
  toLocation?: WarehouseLocation;
  timestamp: Date;
}

export class WarehouseItem {
  readonly id: string;
  readonly sku: string;
  private _name: string;
  readonly categoryCode: string;
  readonly unit: WarehouseUnit;
  private _quantity: number;
  private _unitCostVND: number;
  private _location: WarehouseLocation;
  private _locationNote?: string;
  private _status: WarehouseItemStatus;
  readonly minTHReshold: number;
  private _insuranceStatus: WarehouseItemProps['insuranceStatus'];
  readonly supplierId?: string;
  private _lastCountDate?: Date;
  private _notes?: string;
  readonly createdAt: Date;
  private _updatedAt: Date;
  private _movements: MovementRecord[] = [];

  constructor(props: WarehouseItemProps) {
    this.id = props.id;
    this.sku = props.sku;
    this._name = props.name;
    this.categoryCode = props.categoryCode;
    this.unit = props.unit;
    this._quantity = props.quantity;
    this._unitCostVND = props.unitCostVND;
    this._location = props.location;
    this._locationNote = props.locationNote;
    this._status = props.status;
    this.minTHReshold = props.minTHReshold;
    this._insuranceStatus = props.insuranceStatus;
    this.supplierId = props.supplierId;
    this._lastCountDate = props.lastCountDate;
    this._notes = props.notes;
    this.createdAt = props.createdAt;
    this._updatedAt = props.updatedAt;
  }

  // ─── Getters ───

  get name(): string { return this._name; }
  get quantity(): number { return this._quantity; }
  get unitCostVND(): number { return this._unitCostVND; }
  get totalValueVND(): number { return Math.round(this._quantity * this._unitCostVND); }
  get location(): WarehouseLocation { return this._location; }
  get status(): WarehouseItemStatus { return this._status; }
  get insuranceStatus(): WarehouseItemProps['insuranceStatus'] { return this._insuranceStatus; }
  get movements(): MovementRecord[] { return [...this._movements]; }

  // ─── Stock operations ───

  receiveStock(quantity: number, unitCost: number, performedBy: string): void {
    if (quantity <= 0) throw new Error('[WAREHOUSE] Số lượng nhập phải > 0');

    // Tính giá bình quân mới
    const totalValue = this._quantity * this._unitCostVND + quantity * unitCost;
    const newQty = this._quantity + quantity;
    this._unitCostVND = Math.round(totalValue / newQty);
    this._quantity = newQty;
    this._updatedAt = new Date();
    this._refreshStatus();

    this._movements.push({
      type: 'IN',
      quantity,
      reason: 'Nhập kho',
      performedBy,
      toLocation: this._location,
      timestamp: new Date(),
    });
  }

  releaseStock(quantity: number, reason: string, performedBy: string): void {
    if (quantity <= 0) throw new Error('[WAREHOUSE] Số lượng xuất phải > 0');
    if (quantity > this._quantity) throw new Error(`[WAREHOUSE] Tồn kho không đủ: có ${this._quantity}, yêu cầu ${quantity}`);

    this._quantity -= quantity;
    this._updatedAt = new Date();
    this._refreshStatus();

    this._movements.push({
      type: 'OUT',
      quantity,
      reason,
      performedBy,
      fromLocation: this._location,
      timestamp: new Date(),
    });
  }

  adjustStock(newQuantity: number, reason: string, performedBy: string): void {
    if (newQuantity < 0) throw new Error('[WAREHOUSE] Số lượng điều chỉnh không thể âm');
    const diff = newQuantity - this._quantity;
    this._quantity = newQuantity;
    this._lastCountDate = new Date();
    this._updatedAt = new Date();
    this._refreshStatus();

    this._movements.push({
      type: 'ADJUST',
      quantity: Math.abs(diff),
      reason: `Kiểm kê: ${reason} (${diff >= 0 ? '+' : ''}${diff})`,
      performedBy,
      timestamp: new Date(),
    });
  }

  // ─── Status ───

  private _refreshStatus(): void {
    if (this._quantity === 0) { this._status = 'OUT_OF_STOCK'; return; }
    if (this._quantity <= this.minTHReshold) { this._status = 'LOW_STOCK'; return; }
    if (this._status === 'OUT_OF_STOCK' || this._status === 'LOW_STOCK') {
      this._status = 'AVAILABLE';
    }
  }

  markDamaged(notes: string): void {
    this._status = 'DAMAGED';
    this._notes = notes;
    this._updatedAt = new Date();
  }

  updateInsurance(status: WarehouseItemProps['insuranceStatus']): void {
    this._insuranceStatus = status;
    this._updatedAt = new Date();
  }

  isLowStock(): boolean {
    return this._quantity <= this.minTHReshold && this._quantity > 0;
  }

  isOutOfStock(): boolean {
    return this._quantity === 0;
  }

  // ─── Serialize ───

  toJSON(): WarehouseItemProps {
    return {
      id: this.id,
      sku: this.sku,
      name: this._name,
      categoryCode: this.categoryCode,
      unit: this.unit,
      quantity: this._quantity,
      unitCostVND: this._unitCostVND,
      location: this._location,
      locationNote: this._locationNote,
      status: this._status,
      minTHReshold: this.minTHReshold,
      insuranceStatus: this._insuranceStatus,
      supplierId: this.supplierId,
      lastCountDate: this._lastCountDate,
      notes: this._notes,
      createdAt: this.createdAt,
      updatedAt: this._updatedAt,
    };
  }
}

### src/cells/infrastructure/warehouse-cell/domain/entities/WarehouseEntity.ts ###
export interface WarehouseEntity {
  id: string;
  name: string;
  location: string;
  capacity: number;
  currentStock: number;
}

export interface WarehouseItem {
  id: string;
  name: string;
  quantity: number;
}

### src/cells/infrastructure/warehouse-cell/services/warehouse-domain.service.ts ###
import { WarehouseDomainService as DomainService } from '../domain/services/WarehouseDomainService';
export { DomainService as WarehouseDomainService };

export type QAAuditResult = {
  healthScore: number;
  totalItems: number;
  totalValueVND: number;
  stockAlerts: any[];
  insuranceAlerts: any[];
  unregisteredCategories: any[];
};

### src/cells/infrastructure/warehouse-cell/services/warehouse.engine.ts ###
export class WarehouseEngine {
  static calculateAvailableSpace(WAREHOUSE: { capacity: number; currentStock: number }): number {
    return WAREHOUSE.capacity - WAREHOUSE.currentStock;
  }

  static validateNewItem(
    sku: string,
    name: string,
    categoryCode: string,
    initialQty: number,
    unitCostVND: number,
    registry: any
  ): string[] {
    const errors: string[] = [];
    if (!sku) errors.push('SKU is required');
    if (!name) errors.push('Name is required');
    if (!categoryCode) errors.push('Category code is required');
    if (!registry.findByCode(categoryCode)) errors.push('Category code does not exist');
    if (initialQty < 0) errors.push('Initial quantity must be non-negative');
    if (unitCostVND < 0) errors.push('Unit cost must be non-negative');
    return errors;
  }

  static suggestMinTHReshold(categoryCode: string, registry: any): number {
    const cat = registry.findByCode(categoryCode);
    return cat?.isConsumable ? 10 : 5;
  }

  static computeStatus(stock: number, tHReshold?: number): string { 
    return stock > 0 ? 'IN_STOCK' : 'OUT_OF_STOCK'; 
  }

  static validateReceive(quantity: number): string[] { 
    return quantity > 0 ? [] : ["Số lượng phải lớn hơn 0"]; 
  }

  static validateRelease(item: any, quantity: number): string[] { 
    const errors: string[] = [];
    if (quantity <= 0) errors.push("Số lượng phải lớn hơn 0");
    if (item.quantity < quantity) errors.push("Không đủ hàng trong kho");
    return errors;
  }
}

### src/cells/infrastructure/warehouse-cell/entities/warehouse.entity.ts ###
export interface WarehouseItemProps {
  id: string;
  sku: string;
  name: string;
  categoryCode: string;
  unit: string;
  quantity: number;
  unitCostVND: number;
  location: string;
  locationNote?: string;
  minTHReshold: number;
  supplierId?: string;
  notes?: string;
  insuranceStatus: 'COVERED' | 'NOT_COVERED' | 'EXPIRED';
  createdAt: Date;
  updatedAt: Date;
  createdBy: string;
}

export class WarehouseItem {
  public readonly id: string;
  public readonly sku: string;
  public readonly name: string;
  public readonly categoryCode: string;
  public readonly unit: string;
  private _quantity: number;
  private _unitCostVND: number;
  public readonly location: string;
  public readonly locationNote?: string;
  public readonly minTHReshold: number;
  public readonly supplierId?: string;
  public readonly notes?: string;
  private _insuranceStatus: 'COVERED' | 'NOT_COVERED' | 'EXPIRED';
  public readonly createdAt: Date;
  private _updatedAt: Date;
  public readonly createdBy: string;
  public readonly movements: Array<{
    type: 'IN' | 'OUT' | 'ADJUST' | 'DAMAGED';
    quantity: number;
    unitCostVND?: number;
    reason?: string;
    timestamp: Date;
    by: string;
  }> = [];

  constructor(props: WarehouseItemProps) {
    this.id = props.id;
    this.sku = props.sku;
    this.name = props.name;
    this.categoryCode = props.categoryCode;
    this.unit = props.unit;
    this._quantity = props.quantity;
    this._unitCostVND = props.unitCostVND;
    this.location = props.location;
    this.locationNote = props.locationNote;
    this.minTHReshold = props.minTHReshold;
    this.supplierId = props.supplierId;
    this.notes = props.notes;
    this._insuranceStatus = props.insuranceStatus;
    this.createdAt = props.createdAt;
    this._updatedAt = props.updatedAt;
    this.createdBy = props.createdBy;
  }

  get quantity(): number { return this._quantity; }
  get unitCostVND(): number { return this._unitCostVND; }
  get insuranceStatus(): string { return this._insuranceStatus; }
  get updatedAt(): Date { return this._updatedAt; }

  receiveStock(quantity: number, unitCostVND: number, receivedBy: string) {
    // Tính bình quân gia quyền
    const totalValue = this._quantity * this._unitCostVND + quantity * unitCostVND;
    this._quantity += quantity;
    this._unitCostVND = totalValue / this._quantity;
    this._updatedAt = new Date();
    this.movements.push({ type: 'IN', quantity, unitCostVND, timestamp: new Date(), by: receivedBy });
  }

  releaseStock(quantity: number, reason: string, releasedBy: string) {
    if (quantity > this._quantity) throw new Error('Not enough stock');
    this._quantity -= quantity;
    this._updatedAt = new Date();
    this.movements.push({ type: 'OUT', quantity, reason, timestamp: new Date(), by: releasedBy });
  }

  adjustStock(newQuantity: number, reason: string, adjustedBy: string) {
    const oldQty = this._quantity;
    this._quantity = newQuantity;
    this._updatedAt = new Date();
    this.movements.push({ type: 'ADJUST', quantity: newQuantity - oldQty, reason, timestamp: new Date(), by: adjustedBy });
  }

  markDamaged(notes: string) {
    this.movements.push({ type: 'DAMAGED', quantity: 0, reason: notes, timestamp: new Date(), by: 'system' });
  }

  updateInsurance(status: 'COVERED' | 'NOT_COVERED' | 'EXPIRED') {
    this._insuranceStatus = status;
    this._updatedAt = new Date();
  }

  isLowStock(): boolean {
    return this._quantity > 0 && this._quantity <= this.minTHReshold;
  }

  isOutOfStock(): boolean {
    return this._quantity === 0;
  }
}

--- 4. EVENT-BRIDGE ---

/**
 * 🔄 NATT-OS REDIRECT GATEWAY
 * ⚠️ DEPRECATED: Logic has moved to cells/event-cell/
 */
export { EventBridgeProvider as EventBridge } from '@/cells/event-cell/event-bridge.service';

--- 5. AUDIT SERVICE ---
### src/admin/auditservice.ts ###
export const AuditService = {
  log: (action: string, data: any) => {},
};

export class AuditProvider {
  static logAction(_actor: string, _action: string, _meta?: unknown): void {}
  static getInstance(): AuditProvider { return new AuditProvider(); }
}
export default AuditProvider;
### src/services/admin/auditservice.ts ###
// Admin Audit Service - will be implemented later
export class AuditService {
  static getInstance() {
    return new AuditService();
  }
  getLogs() {
    return [];
  }
}

--- 6. ALL ERROR FILES (từ tsc) ---

### src/services/recovery-engine.ts ###

import { OperationRecord, Checkpoint } from '@/types';

/**
 * NATT-OS RECOVERY ENGINE v5.2
 * Kế thừa logic xử lý lỗi và phục hồi trạng thái từ kiến trúc Shard.
 */
class RecoveryEngine {
  private static instance: RecoveryEngine;
  private opLog: OperationRecord[] = [];
  private checkpoints: Map<string, Checkpoint> = new Map();
  private deadLetterQueue: OperationRecord[] = [];
  
  private readonly MAX_RETRIES = 3;

  static getInstance() {
    if (!RecoveryEngine.instance) RecoveryEngine.instance = new RecoveryEngine();
    return RecoveryEngine.instance;
  }

  /**
   * ✅ Record Operation
   */
  recordOperation(type: string, module: string, params: any): string {
    const id = `OP-${Date.now()}-${Math.random().toString(36).substring(2,7).toUpperCase()}`;
    const newOp: OperationRecord = {
      id,
      type,
      module,
      params,
      timestamp: Date.now(),
      status: 'PENDING'
    };
    
    this.opLog.unshift(newOp);
    
    // Nếu là Repair Node, đưa vào Dead Letter để User Fix
    if (type === 'REPAIR_NODE') {
        newOp.status = 'FAILED';
        newOp.error = 'SHARD_INTEGRITY_FAIL: Cần Master xác thực bản Backup.';
        this.deadLetterQueue.unshift(newOp);
    }

    if (this.opLog.length > 500) this.opLog.pop();
    return id;
  }

  completeOperation(id: string) {
    const op = this.opLog.find(o => o.id === id);
    if (op) op.status = 'SUCCESS';
  }

  async reportFailure(id: string, error: any, strategy: 'RETRY' | 'MANUAL' = 'RETRY') {
    const op = this.opLog.find(o => o.id === id);
    if (!op) return;

    op.status = 'FAILED';
    op.error = error.message || String(error);

    if (strategy === 'RETRY') {
       await this.attemptRetry(op);
    } else {
       this.moveToDeadLetter(op);
    }
  }

  private async attemptRetry(op: OperationRecord) {
    let attempts = 0;
    while (attempts < this.MAX_RETRIES) {
      attempts += 1;
      await new Promise(r => setTimeout(r, 800));

      if (Math.random() > 0.6) {
          op.status = 'RECOVERED';
          op.error = undefined;
          return;
      }
    }
    this.moveToDeadLetter(op);
  }

  private moveToDeadLetter(op: OperationRecord) {
    if (!this.deadLetterQueue.some(d => d.id === op.id)) {
        this.deadLetterQueue.unshift(op);
    }
  }

  createCheckpoint(module: string, state: any): string {
    const id = `CHK-${Date.now()}`;
    this.checkpoints.set(id, { id, moduleState: state, timestamp: Date.now() });
    return id;
  }

  getDeadLetterQueue() { return this.deadLetterQueue; }
  
  async replayOperation(id: string) {
     const op = this.deadLetterQueue.find(o => o.id === id);
     if (!op) return false;
     
     // Giả lập logic khôi phục thực tế
     await new Promise(r => setTimeout(r, 1200));
     op.status = 'RECOVERED';
     op.error = undefined;
     this.deadLetterQueue = this.deadLetterQueue.filter(o => o.id !== id);
     
     console.log(`[RECOVERY] Shard ${op.module} has been successfully restored from local shadow storage.`);
     return true;
  }
}

export const RecoverySystem = RecoveryEngine.getInstance();

### src/services/module-registry.ts ###

import { ViewType, UserRole, ModuleConfig } from '@/types';

export const MODULE_REGISTRY: Record<string, ModuleConfig> = {
  [ViewType.DASHBOARD]: { id: ViewType.DASHBOARD, title: 'TỔNG QUAN', icon: '🏠', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.ADMIN, UserRole.MANAGER], componentName: 'MasterDashboard', active: true },
  [ViewType.sales_tax]: { id: ViewType.sales_tax, title: 'FISCAL TERMINAL (HDĐT)', icon: '📊', group: 'ACCOUNTING', allowedRoles: [UserRole.ADMIN, UserRole.MANAGER, UserRole.SALES_STAFF], componentName: 'SalesTaxModule', active: true },
  [ViewType.production_manager]: { id: ViewType.production_manager, title: 'XƯỞNG CHẾ TÁC', icon: '🏭', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.MANAGER, UserRole.SENIOR_STAFF], componentName: 'ProductionManager', active: true },
  [ViewType.WAREHOUSE]: { id: ViewType.WAREHOUSE, title: 'KHO TỔNG', icon: '📦', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.MANAGER, UserRole.SENIOR_STAFF], componentName: 'WarehouseManagement', active: true },
  [ViewType.HR]: { id: ViewType.HR, title: 'NHÂN SỰ', icon: '👥', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.MANAGER, UserRole.SENIOR_STAFF], componentName: 'HRManagement', active: true },
  [ViewType.command]: { id: ViewType.command, title: 'COMMAND CENTER', icon: '🔱', group: 'CORE', allowedRoles: [UserRole.ADMIN], componentName: 'ThienCommandCenter', active: true },
  [ViewType.chat]: { id: ViewType.chat, title: 'CHAT ADVISOR', icon: '💬', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.ADMIN], componentName: 'ChatConsultant', active: true },
  [ViewType.audit_center]: { id: ViewType.audit_center, title: 'DEEP AUDIT HUB', icon: '🔍', group: 'SYSTEM', allowedRoles: [UserRole.ADMIN, UserRole.AUDITOR], componentName: 'AuditDashboard', active: true },
  [ViewType.sales_terminal]: { id: ViewType.sales_terminal, title: 'CHỐT ĐƠN HÀNG', icon: '🛍️', group: 'CORE', allowedRoles: [UserRole.ADMIN, UserRole.ADMIN, UserRole.MANAGER, UserRole.SALES_STAFF], componentName: 'SaleTerminal', active: true },
  // NEW SHOWROOM V2 MODULE
  [ViewType.SHOWROOM]: { id: ViewType.SHOWROOM, title: 'SHOWROOM V2 (BETA)', icon: '💎', group: 'SALES', allowedRoles: [UserRole.ADMIN, UserRole.ADMIN, UserRole.MANAGER, UserRole.SALES_STAFF, UserRole.VIEWER], componentName: 'ProductPage', active: true },
};

export class ModuleRegistryService {
  private static instance: ModuleRegistryService;
  private constructor() {}

  static getInstance() {
    if (!ModuleRegistryService.instance) ModuleRegistryService.instance = new ModuleRegistryService();
    return ModuleRegistryService.instance;
  }

  getAllModules(): ModuleConfig[] {
    return Object.values(MODULE_REGISTRY);
  }

  registerModule(config: ModuleConfig) {
    MODULE_REGISTRY[config.id] = config;
  }
}

export const ModuleRegistry = ModuleRegistryService.getInstance();
export default ModuleRegistry;

### src/services/analytics/analytics-api.ts ###

import { GovernanceKPI, TeamPerformance, BusinessMetrics } from '@/types';

/**
 * 📊 ANALYTICS API (TEAM 4 - BĂNG)
 * Chịu trách nhiệm cung cấp dữ liệu cho bảng điều hành.
 */
export class AnalyticsAPI {
  private static instance: AnalyticsAPI;

  public static getInstance(): AnalyticsAPI {
    if (!AnalyticsAPI.instance) {
      AnalyticsAPI.instance = new AnalyticsAPI();
    }
    return AnalyticsAPI.instance;
  }

  /**
   * Lấy danh sách KPI quản trị (Thien Command Center)
   */
  public async getGovernanceKPIs(): Promise<GovernanceKPI[]> {
    const now = new Date().toISOString().split('T')[0];
    return [
      {
        kpi_id: 'KPI-001',
        kpi_name: 'Tổng doanh thu (NET)',
        category: 'FINANCIAL',
        period_date: now,
        target_value: 500000000,
        actual_value: 449120000,
        previous_value: 410000000,
        change_percent: 9.5,
        status: 'OK',
        owner_team: 'Bối Bối',
        tHReshold_warning: 400000000,
        tHReshold_critical: 300000000
      },
      {
        kpi_id: 'KPI-002',
        kpi_name: 'Hao hụt sản xuất (WIP)',
        category: 'OPERATIONAL',
        period_date: now,
        target_value: 1.0,
        actual_value: 1.2,
        previous_value: 0.8,
        change_percent: 50,
        status: 'WARNING',
        owner_team: 'Bối Bối',
        tHReshold_warning: 1.1,
        tHReshold_critical: 1.5
      },
      {
        kpi_id: 'KPI-003',
        kpi_name: 'Độ trễ Shard (Avg)',
        category: 'STRATEGIC',
        period_date: now,
        target_value: 50,
        actual_value: 12,
        previous_value: 15,
        change_percent: -20,
        status: 'OK',
        owner_team: 'KIM',
        tHReshold_warning: 100,
        tHReshold_critical: 500
      }
    ];
  }

  /**
   * Thống kê tải trọng các Team AI
   */
  public async getTeamPerformance(): Promise<TeamPerformance[]> {
    return [
      { team_name: 'Bối Bối (Team 1)', total_tasks: 124, tasks_completed: 110, tasks_in_progress: 10, tasks_blocked: 4, load_percentage: 85, completion_rate: 88.7 },
      { team_name: 'ChatGPT (Team 2)', total_tasks: 85, tasks_completed: 80, tasks_in_progress: 5, tasks_blocked: 0, load_percentage: 60, completion_rate: 94.1 },
      { team_name: 'KIM (Team 3)', total_tasks: 42, tasks_completed: 40, tasks_in_progress: 2, tasks_blocked: 0, load_percentage: 30, completion_rate: 95.2 },
      { team_name: 'BĂNG (Team 4)', total_tasks: 15, tasks_completed: 15, tasks_in_progress: 0, tasks_blocked: 0, load_percentage: 10, completion_rate: 100 }
    ];
  }
}

export const AnalyticsProvider = AnalyticsAPI.getInstance();

### src/services/analytics/analytics-service.ts ###

import { EventEnvelope, PersonaID } from '@/types';
import { EventBridge } from '../../eventbridge';
import { AuditProvider } from '../../admin/auditservice';

/**
 * 🧠 ANALYTICS SERVICE (TEAM 4 - BĂNG)
 * Chịu trách nhiệm bóc tách sự kiện sang Read-models.
 */
export class AnalyticsService {
  private static instance: AnalyticsService;

  public static getInstance(): AnalyticsService {
    if (!AnalyticsService.instance) {
      AnalyticsService.instance = new AnalyticsService();
    }
    return AnalyticsService.instance;
  }

  public init() {
    console.log('[ANALYTICS] BĂNG is observing the Event Bus...');
    
    // Đăng ký nhận mọi sự kiện quan trọng để cập nhật Dashboard
    EventBridge.subscribe('sales.order.created.v1', (e) => this.handleOrderUpdate(e));
    EventBridge.subscribe('finance.payment.completed.v1', (e) => this.handleFinanceUpdate(e));
    EventBridge.subscribe('admin.role.assigned.v1', (e) => this.handleSecurityUpdate(e));
  }

  private async handleOrderUpdate(event: EventEnvelope) {
    await AuditProvider.logAction('ANALYTICS', 'ORDER_READ_MODEL_UPDATE', { id: event.payload.id }, 'analytics-service', event.event_id);
    console.log(`[ANALYTICS] Updated Order Read-Model for: ${event.payload.id}`);
  }

  private async handleFinanceUpdate(event: EventEnvelope) {
    console.log(`[ANALYTICS] Re-calculating Financial KPIs after payment: ${event.payload.payment_id}`);
  }

  private async handleSecurityUpdate(event: EventEnvelope) {
    console.warn(`[ANALYTICS] Security Signal detected. Correlation: ${event.trace.correlation_id}`);
  }
}

export const AnalyticsEngine = AnalyticsService.getInstance();

### src/services/hr-service.ts ###

import { 
    Department, DetailedPersonnel, 
    HRDepartment, HRPosition, HRAttendance, 
    PositionType, UserRole
} from '@/types';

/**
 * 🛡️ @RequirePermission Stub Decorator Simulation
 * Trong môi trường Frontend, Thiên mô phỏng ranh giới này để chuẩn bị cho Backend.
 */
function RequirePermission(permission: string) {
    return function (_target: any, _propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = function (...args: any[]) {
            console.log(`[RBAC_GATE] Checking authorization for: ${permission}`);
            // Logic check quyền thực tế sẽ bind tại đây
            return originalMethod.apply(this, args);
        };
        return descriptor;
    };
}

class HRService {
  private static instance: HRService;
  
  private employees: DetailedPersonnel[] = [
    { 
        id: 'e1', employeeCode: 'TL-M001', fullName: 'ADMIN NATT', email: 'natt@luxurytam.com', 
        position: { id: 'pos-1', role: PositionType.CFO, department: Department.ACCOUNTING, scope: ['ALL'] },
        role: UserRole.ADMIN,
        status: 'ACTIVE', baseSalary: 0, 
        startDate: '2020-01-01', kpiPoints: 999, tasksCompleted: 450, lastRating: 'ADMIN',
        bankAccountNo: '0071001234567',
        allowanceLunch: 0, allowancePosition: 0, actualWorkDays: 22,
        bio: 'Kiểm toán độc lập, Tổng tham mưu chiến lược.'
    },
    { 
        id: 'e2', employeeCode: 'TL-S007', fullName: 'LÊ TRỌNG KHÔI', email: 'khoi.lt@luxurytam.com', 
        position: { id: 'pos-2', role: PositionType.CONSULTANT, department: Department.SALES, scope: ['CLIENTS'] },
        role: UserRole.SALES_STAFF,
        status: 'ACTIVE', baseSalary: 15000000, 
        startDate: '2023-05-12', kpiPoints: 105, tasksCompleted: 120, lastRating: 'OPTIMAL',
        bankAccountNo: '1903001234567',
        allowanceLunch: 800000, allowancePosition: 1000000, actualWorkDays: 26,
        bio: 'Best Seller 2024.'
    }
  ];

  static getInstance() {
    if (!HRService.instance) HRService.instance = new HRService();
    return HRService.instance;
  }

  @RequirePermission('HR_EMPLOYEE_READ')
  async getEmployees(params?: any): Promise<{ data: DetailedPersonnel[], meta: any }> {
    let data = [...this.employees];
    if (params?.search) {
        const s = params.search.toLowerCase();
        data = data.filter(e => e.fullName.toLowerCase().includes(s) || e.employeeCode.toLowerCase().includes(s));
    }
    return { data, meta: { total: data.length } };
  }

  @RequirePermission('HR_ATTENDANCE_READ')
  async getAttendance(employeeId: string): Promise<HRAttendance[]> {
      const mockSources: Array<'MACHINE' | 'OMEGA_SYNC' | 'HR_ADJUSTED'> = ['MACHINE', 'OMEGA_SYNC', 'HR_ADJUSTED'];
      
      return Array.from({ length: 5 }).map((_, i) => ({
          id: `att-${i}`,
          employee_id: employeeId,
          date: `2026-01-0${i+1}`,
          checkIn: Date.now() - (i * 86400000),
          total_hours: 8,
          status: 'PRESENT',
          source: {
              type: mockSources[i % 3],
              deviceId: 'CAM-OMEGA-01',
              hash: `0x${Math.random().toString(16).slice(2, 40)}`,
              adjustedBy: i % 3 === 2 ? 'HR_MANAGER_01' : undefined
          }
      }));
  }

  async getDepartments(): Promise<HRDepartment[]> {
      return [
          { id: 'd1', code: 'HEADQUARTER', name: 'Ban Giám Đốc', is_active: true, description: 'Lõi chỉ huy' },
          { id: 'd2', code: 'ACCOUNTING', name: 'Phòng Tài Chính', is_active: true, description: 'Quản trị dòng tiền' },
          { id: 'd3', code: 'PRODUCTION', name: 'Khối Sản Xuất', is_active: true, description: 'Chế tác' }
      ];
  }

  async getPositions(): Promise<HRPosition[]> {
      return [
          { id: 'p1', code: 'CFO', title: 'Giám đốc Tài Chính', department_id: 'd2', is_active: true },
          { id: 'p2', code: 'PROD_DIR', title: 'Giám đốc Sản Xuất', department_id: 'd3', is_active: true }
      ];
  }
}

export const HRProvider = HRService.getInstance();

### src/services/mapping/smart-link-mapping-engine.ts ###
import {
  AccountingEntry,
  AccountingMappingRule,
  SalesEvent
} from '@/types';

// Simple Event Emitter implementation for browser environment
class SimpleEventEmitter {
  private listeners: Record<string, Function[]> = {};

  on(event: string, listener: Function) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(listener);
  }

  emit(event: string, ...args: any[]) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(listener => listener(...args));
    }
  }

  removeAllListeners() {
    this.listeners = {};
  }
}

export class SmartLinkMappingEngine extends SimpleEventEmitter {
  private static instance: SmartLinkMappingEngine;
  private mappingRules: Map<string, AccountingMappingRule> = new Map();
  private syncQueue: Array<{entry: AccountingEntry, retries: number}> = [];
  private isProcessing: boolean = false;
  
  private constructor() {
    super();
    this.initializeDefaultMappings();
    this.startQueueProcessor();
  }
  
  public static getInstance(): SmartLinkMappingEngine {
    if (!SmartLinkMappingEngine.instance) {
      SmartLinkMappingEngine.instance = new SmartLinkMappingEngine();
    }
    return SmartLinkMappingEngine.instance;
  }
  
  private initializeDefaultMappings(): void {
    const defaultRules: AccountingMappingRule[] = [
      {
        id: 'REVENUE_MAPPING',
        name: 'Doanh thu bán hàng',
        description: 'Ánh xạ doanh thu từ đơn hàng sang tài khoản kế toán',
        source: { system: 'SALES', entity: 'SalesOrder', eventType: 'ORDER_CREATED' },
        sourceField: 'pricing.totalAmount',
        destination: { system: 'ACCOUNTING', entity: 'JournalEntry', accountType: 'REVENUE' },
        destinationField: 'debit_accounts.revenue',
        mappingType: 'DIRECT',
        // 🛠️ Fixed: Added optional context parameter to satisfy AccountingMappingRule's transformation type
        transformation: (value: number, context?: any) => ({
          debit: '131',
          credit: '511',
          amount: value,
          taxCode: '01GTGT',
          description: 'Doanh thu bán hàng hóa'
        }),
        autoPost: true,
        enabled: true,
        priority: 1,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      {
        id: 'COGS_MAPPING',
        name: 'Giá vốn hàng bán',
        description: 'Giá vốn hàng bán',
        source: { system: 'INVENTORY', entity: 'StockOut', eventType: 'ORDER_FULFILLED' },
        sourceField: 'pricing.costOfGoods',
        destination: { system: 'ACCOUNTING', entity: 'JournalEntry', accountType: 'COGS' },
        destinationField: 'accounts.cogs',
        mappingType: 'DIRECT',
        // 🛠️ Fixed: Added optional context parameter to satisfy AccountingMappingRule's transformation type
        transformation: (value: number, context?: any) => ({
          debit: '632',
          credit: '156',
          amount: value,
          description: 'Giá vốn hàng bán'
        }),
        autoPost: true,
        enabled: true,
        priority: 2,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];
    
    defaultRules.forEach(rule => this.addMappingRule(rule));
  }
  
  public async autoMapSalesEvent(event: SalesEvent): Promise<AccountingEntry[]> {
    const entries: AccountingEntry[] = [];
    
    try {
      const applicableRules = this.findApplicableRules(event);
      
      for (const rule of applicableRules) {
        const mappedEntries = await this.applyMappingRule(rule, event);
        entries.push(...mappedEntries);
      }
      
      this.emit('entriesMapped', { event, entries });
      
      if (entries.length > 0) {
        // In a real app, this would call an API
        entries.forEach(e => e.status = 'POSTED');
      }
      
    } catch (error) {
      console.error('Error in autoMapSalesEvent:', error);
      this.emit('mappingError', { event, error });
    }
    
    return entries;
  }
  
  private findApplicableRules(event: SalesEvent): AccountingMappingRule[] {
    const applicable: AccountingMappingRule[] = [];
    
    for (const rule of this.mappingRules.values()) {
      if (!rule.enabled) continue;
      
      // Simplified matching logic for demo
      if (rule.source.system === 'SALES' && event.type === 'ORDER_CREATED') {
         applicable.push(rule);
      }
    }
    return applicable.sort((a, b) => b.priority - a.priority);
  }
  
  private async applyMappingRule(
    rule: AccountingMappingRule, 
    event: SalesEvent
  ): Promise<AccountingEntry[]> {
    // Mock extraction
    let value = 0;
    if (rule.id === 'REVENUE_MAPPING') value = event.order?.pricing?.totalAmount || 0;
    if (rule.id === 'COGS_MAPPING') value = event.order?.pricing?.costOfGoods || 0;

    try {
      const result = rule.transformation(value);
      return [this.createAccountingEntry(result, rule, event)];
    } catch (error) {
      console.error(`Error applying rule ${rule.id}:`, error);
      throw error;
    }
  }
  
  private createAccountingEntry(
    data: any,
    rule: AccountingMappingRule,
    event: SalesEvent,
    index: number = 0
  ): AccountingEntry {
    const journalId = `JRN-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
    
    return {
      journalId,
      transactionDate: new Date(),
      description: data.description || `Auto-mapped from ${event.type}`,
      entries: [{
        accountNumber: data.debit || '',
        accountName: 'Auto Account', // In real app, fetch name
        debit: data.amount || 0,
        credit: 0,
        currency: 'VND'
      }, {
        accountNumber: data.credit || '',
        accountName: 'Auto Account',
        debit: 0,
        credit: data.amount || 0,
        currency: 'VND'
      }],
      referenceId: rule.id,
      referenceType: 'MAPPING_RULE',
      reference: {
        ruleId: rule.id,
        eventType: event.type
      },
      status: rule.autoPost ? 'POSTED' : 'DRAFT',
      // Added matchScore to satisfy AccountingEntry interface
      matchScore: 100,
      createdAt: new Date(),
      journalType: rule.destination.accountType as any
    };
  }
  
  // Public API methods
  public addMappingRule(rule: AccountingMappingRule): void {
    this.mappingRules.set(rule.id, rule);
    this.emit('ruleAdded', rule);
  }
  
  public updateMappingRule(id: string, updates: Partial<AccountingMappingRule>): void {
    const rule = this.mappingRules.get(id);
    if (rule) {
      const updatedRule = { ...rule, ...updates, updatedAt: new Date() };
      this.mappingRules.set(id, updatedRule);
      this.emit('ruleUpdated', updatedRule);
    }
  }
  
  public getMappingRules(): AccountingMappingRule[] {
    return Array.from(this.mappingRules.values());
  }
  
  public getRuleById(id: string): AccountingMappingRule | undefined {
    return this.mappingRules.get(id);
  }
  
  public async testMappingRule(ruleId: string, testData: any): Promise<any> {
    const rule = this.getRuleById(ruleId);
    if (!rule) throw new Error(`Rule ${ruleId} not found`);
    return rule.transformation(testData.value, testData.context);
  }
  
  private startQueueProcessor(): void {
    setInterval(() => {
      this.processQueue();
    }, 5000); 
  }
  
  private async processQueue(): Promise<void> {
    if (this.isProcessing || this.syncQueue.length === 0) return;
    this.isProcessing = true;
    // Simulate processing
    setTimeout(() => { this.isProcessing = false; }, 500);
  }
}
### src/services/fiscal/fiscal-workbench-service.ts ###

import { InvoiceProjection, FiscalLineItem, FiscalTotals, InvoiceIdentity } from '@/types/fiscal_contracts';
import { XmlCanonicalizer } from '@/utils/xmlcanonicalizer';
// TODO: import ShardingService from;
import AuditProvider from "@/admin/auditservice";
import { OmegaLockdown } from '../../core/audit/omegalockdown';

// Helper for Decimal String Math (Fix 1)
// In a real app, use 'decimal.js' or 'big.js'. Here we implement a safe wrapper.
const DecimalMath = {
  add: (a: string, b: string): string => {
    return (Number(a) + Number(b)).toFixed(0); // VND is usually integer-like but handled as string
  },
  sub: (a: string, b: string): string => {
    return (Number(a) - Number(b)).toFixed(0);
  },
  mul: (a: string, qty: string): string => {
    return (Number(a) * Number(qty)).toFixed(0);
  },
  eq: (a: string, b: string): boolean => Number(a) === Number(b)
};

export class FiscalWorkbenchService {
  private static instance: FiscalWorkbenchService;

  static getInstance() {
    if (!FiscalWorkbenchService.instance) FiscalWorkbenchService.instance = new FiscalWorkbenchService();
    return FiscalWorkbenchService.instance;
  }

  /**
   * 1. Create Projection with Strict Diff Guard
   */
  async createProjection(
    orderId: string, 
    items: { type: any, name: string, qty: string, price: string, vat: number }[]
  ): Promise<InvoiceProjection> {
    
    // Check Lockdown (Fix 5 - Logic layer check backup)
    await OmegaLockdown.enforce();

    const lines: FiscalLineItem[] = items.map(i => ({
        item_type: i.type,
        name: i.name,
        qty: i.qty, // String (Fix 2)
        unit_price: i.price, // String (Fix 1)
        amount: DecimalMath.mul(i.price, i.qty), // String Math
        vat_rate: i.vat as any
    }));

    let subTotal = "0";
    let vatTotal = "0";

    lines.forEach(l => {
        subTotal = DecimalMath.add(subTotal, l.amount);
        const vatAmount = (Number(l.amount) * (l.vat_rate / 100)).toFixed(0);
        vatTotal = DecimalMath.add(vatTotal, vatAmount);
    });

    const grandTotal = DecimalMath.add(subTotal, vatTotal);

    // Diff Guard Check
    // In production, 'expected' comes from Sales Order. Here we simulate perfect match.
    const diff = "0"; 

    const projection: InvoiceProjection = {
        tenant_id: 'TAM_LUXURY',
        order_id: orderId,
        invoice_version: 1,
        currency: 'VND',
        buyer: { name: 'Sample Buyer', tax_code: 'MST001', address: 'HCM', email: 'a@b.c' },
        lines,
        totals: {
            sub_total: subTotal,
            vat_total: vatTotal,
            grand_total: grandTotal
        },
        diff_guard: {
            expected_total: grandTotal,
            computed_total: grandTotal,
            diff: diff,
            rule: 'diff_must_be_zero'
        }
    };

    if (diff !== "0") {
        throw new Error(`FISCAL_INTEGRITY_FAIL: Diff Guard not zero (${diff})`);
    }

    return projection;
  }

  /**
   * 2. Generate Canonical XML (Fix 3)
   */
  async generateFiscalXML(projection: InvoiceProjection, identity: InvoiceIdentity): Promise<string> {
    const dataObj = {
        TTChung: {
            KHDon: identity.invoice_series,
            KHMau: identity.template_code,
            SHDon: identity.invoice_sequence,
            TTe: projection.currency
        },
        NDung: {
            NMua: projection.buyer,
            HHDon: projection.lines.map((l, i) => ({
                STT: i + 1,
                Ten: l.name,
                SLuong: l.qty,
                DGia: l.unit_price,
                Thue: l.vat_rate,
                TTien: l.amount
            })),
            TToan: projection.totals
        }
    };

    const xmlRaw = XmlCanonicalizer.buildDeterministicXML('HDon', dataObj);
    return XmlCanonicalizer.canonicalize(xmlRaw);
  }

  /**
   * 3. Seal & Sign
   */
  async sealAndSign(invoiceId: string, xmlContent: string): Promise<string> {
      // Check Lockdown
      await OmegaLockdown.enforce();

      // Compute Hash of Canonical XML
      const xmlHash = ShardingService.generateShardHash({ content: xmlContent });

      // Audit Log
      await AuditProvider.logAction(
          'FISCAL',
          'INVOICE_SEALED',
          { invoiceId, xmlHash },
          'ADMIN_NATT'
      );

      return xmlHash;
  }
}

export const FiscalEngine = FiscalWorkbenchService.getInstance();

### src/natt-os/bootstrap/omega-bootstrap.ts ###

import { AuditProvider } from '@/services/admin/audit-service';

// 🔱 CHỦ QUYỀN TỐI CAO: ANH NAT
const ADMIN_SIGNATURE = 'SIG_BY_ADMIN_NAT_2026';

export interface BootstrapResult {
  success: boolean;
  checks: Array<{
    check: string;
    status: 'PASS' | 'FAIL' | 'PENDING';
    details?: any;
  }>;
  error?: string;
  timestamp: string;
  meta?: any;
}

export class OmegaBootstrap {
  static async activate(): Promise<BootstrapResult> {
    const now = new Date().toISOString();
    const checks: BootstrapResult['checks'] = [
      { check: 'Sovereign DNA (ANH_NAT)', status: 'PENDING' },
      { check: '128 Core Shards Integrity', status: 'PENDING' },
      { check: 'Boundary Law Enforcement', status: 'PENDING' },
      { check: 'SmartLink Registry Lock', status: 'PENDING' }
    ];

    try {
      // 1. Xác thực ADN Master
      checks[0].status = 'PASS';
      checks[0].details = { owner: 'ANH_NAT', sig: ADMIN_SIGNATURE };

      // 2. Quét 128 Shards
      console.log(`[BOOT] Initiating deep scan of 128 shards for owner: ANH_NAT`);
      await new Promise(r => setTimeout(r, 1000));
      checks[1].status = 'PASS';
      checks[1].details = { count: 128, status: 'SEALED' };

      // 3. Thực thi ranh giới
      checks[2].status = 'PASS';
      checks[3].status = 'PASS';

      // Ghi nhật ký khởi động Gold Master
      await AuditProvider.logAction('SYSTEM', 'GOLD_ADMIN_BOOT_SUCCESS', { 
        shards: 128, 
        owner: 'ANH_NAT' 
      }, 'ANH_NAT');

      return {
        success: true,
        checks,
        timestamp: now,
        meta: { 
          sovereign: 'ANH_NAT',
          sealed_nodes: 128,
          plan: 'OMEGA-GOVERNANCE-LONGTERM'
        }
      };
    } catch (error: any) {
      return {
        success: false,
        checks: checks.map(c => c.status === 'PENDING' ? { ...c, status: 'FAIL' } : c),
        error: error.message || 'SOVEREIGN_BOOT_FAILED',
        timestamp: now
      };
    }
  }
}

### src/core/runtime.ts ###

import { RuntimeInput, RuntimeOutput, Event, StateChange } from '@/types';
import { StateManager } from './state-manager';
import { TraceManager } from './trace-manager';
import { PolicyEngine } from './policy-engine';
import { IdempotencyService } from './idempotency-service';
import { OutboxService } from './outbox-service';

export class NATTOS_Runtime {
  private stateManager = new StateManager();
  private traceManager = new TraceManager();
  private policyEngine = new PolicyEngine();
  private idempotencyService = new IdempotencyService();
  private outboxService = new OutboxService();
  
  async handle(input: RuntimeInput): Promise<RuntimeOutput> {
    const startTime = Date.now();
    try {
      // 1. KCS Validation
      if (!input.tenantId) throw new Error('KCS VIOLATION: tenantId is required');
      if (!input.correlationId) throw new Error('KCS VIOLATION: correlationId is required');

      // 2. Start Trace Span
      const span = await this.traceManager.startSpan(input.operation, input);

      // 3. Idempotency Check
      const output = await this.idempotencyService.executeIdempotent(
        { key: `${input.tenantId}:${input.correlationId}`, tenantId: input.tenantId },
        async () => {
          // 4. Policy Enforcement
          const auth = await this.policyEngine.evaluate(input.userId, input.operation, input.domain, input.tenantId);
          if (!auth.allowed) throw new Error(`KCS POLICY DENIED: ${auth.reason}`);

          // 5. State Discipline
          const transition = await this.stateManager.validateTransition(input.domain, input.operation, input.payload, input.tenantId);

          // 6. Execute Business Logic (Mock)
          const result = { entityId: input.payload.id || 'NEW', status: 'SUCCESS' };

          // 7. Record State Change
          await this.stateManager.recordStateChange({
            entityId: result.entityId,
            tenantId: input.tenantId,
            entityType: input.domain,
            fromState: transition.fromState,
            toState: transition.toState,
            changedAt: new Date(),
            changedBy: input.userId,
            causationId: input.correlationId
          });

          // 8. Publish Event via Outbox
          await this.outboxService.publish({
            id: `evt_${Date.now()}`,
            type: `${input.domain}.${input.operation}`,
            correlationId: input.correlationId,
            tenantId: input.tenantId,
            payload: result,
            timestamp: Date.now(),
            source: "runtime"
          } as Event);

          return result;
        }
      );

      return {
        tenantId: input.tenantId,
        correlationId: input.correlationId,
        success: true,
        data: output,
        metadata: {
          tenantId: input.tenantId,
          processedAt: new Date(),
          processingMs: Date.now() - startTime,
          stateChanges: [], // Populated in real impl
          eventsPublished: []
        }
      };

    } catch (error: any) {
      return {
        tenantId: input.tenantId,
        correlationId: input.correlationId,
        success: false,
        error: error.message || String(error),
        metadata: { tenantId: input.tenantId, processedAt: new Date(), processingMs: Date.now() - startTime, stateChanges: [], eventsPublished: [] }
      };
    }
  }
}

export const runtime = new NATTOS_Runtime();

### src/core/core/smart-link-engine.ts ###
import { 
  AccountingEntry, 
  SalesOrder, 
  BankTransaction, 
  CostAllocation, 
  AccountingMappingRule, 
  SalesEvent 
} from '@/types';

/**
 * ⚛️ SMART LINK OMEGA ENGINE (UNIFIED CORE)
 * Hợp nhất logic bóc tách bút toán TT200 và ánh xạ sự kiện động.
 * Đảm bảo "Sự thật duy nhất" (Single Source of Truth) cho hệ thống 19TB.
 */
class SmartLinkEngine {
  private static instance: SmartLinkEngine;
  private mappingRules: Map<string, AccountingMappingRule> = new Map();
  private listeners: Record<string, Function[]> = {};

  // Danh mục tài khoản chuẩn (TT200)
  public static readonly COA: Record<string, string> = {
    '111': 'Tiền mặt',
    '112': 'Tiền gửi ngân hàng',
    '131': 'Phải thu khách hàng',
    '156': 'Hàng hóa (Kho)',
    '331': 'Phải trả người bán',
    '3331': 'Thuế GTGT phải nộp',
    '511': 'Doanh thu bán hàng',
    '632': 'Giá vốn hàng bán',
    '641': 'Chi phí bán hàng',
    '642': 'Chi phí quản lý',
    '811': 'Chi phí khác',
    '711': 'Thu nhập khác',
    '334': 'Phải trả người lao động',
    '242': 'Chi phí trả trước'
  };

  private constructor() {
    this.initializeDefaultMappings();
  }

  public static getInstance(): SmartLinkEngine {
    if (!SmartLinkEngine.instance) {
      SmartLinkEngine.instance = new SmartLinkEngine();
    }
    return SmartLinkEngine.instance;
  }

  // --- EVENT SYSTEM ---
  public on(event: string, listener: Function) {
    if (!this.listeners[event]) this.listeners[event] = [];
    this.listeners[event].push(listener);
  }

  private emit(event: string, ...args: any[]) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(l => l(...args));
    }
  }

  public removeAllListeners() {
    this.listeners = {};
  }

  // --- LOGIC MAPPING (DYNAMIC) ---
  private initializeDefaultMappings(): void {
    const defaultRules: AccountingMappingRule[] = [
      {
        id: 'REVENUE_MAPPING',
        
        description: 'Ánh xạ doanh thu từ đơn hàng sang tài khoản kế toán',
        
        
        destination: { system: 'ACCOUNTING', entity: 'JournalEntry', accountType: 'REVENUE' },
        destinationField: 'debit_accounts.revenue',
        mappingType: 'DIRECT',
        transformation: (value: number) => ({ debit: '131', credit: '511', amount: value, description: 'Doanh thu bán hàng hóa' }),
        autoPost: true,
        enabled: true,
        priority: 1,
        createdAt: new Date(),
        updatedAt: new Date()
      }
    ];
    defaultRules.forEach(rule => this.mappingRules.set(rule.id, rule));
  }

  public getMappingRules(): AccountingMappingRule[] {
    return Array.from(this.mappingRules.values());
  }

  public addMappingRule(rule: AccountingMappingRule): void {
    this.mappingRules.set(rule.id, rule);
    this.emit('ruleAdded', rule);
  }

  public updateMappingRule(id: string, updates: Partial<AccountingMappingRule>): void {
    const rule = this.mappingRules.get(id);
    if (rule) {
      const updated = { ...rule, ...updates, updatedAt: new Date() };
      this.mappingRules.set(id, updated);
      this.emit('ruleUpdated', updated);
    }
  }

  /**
   * Ánh xạ tự động một sự kiện kinh doanh thành bút toán
   */
  public async autoMapSalesEvent(event: SalesEvent): Promise<AccountingEntry[]> {
    const entries: AccountingEntry[] = [];
    if (event.type === 'ORDER_CREATED' && event.order) {
        // Hợp nhất logic tạo từ Sales
        const generated = this.generateFromSales(event.order);
        entries.push(...generated);
    }
    this.emit('entriesMapped', { event, entries });
    return entries;
  }

  // --- LOGIC GENERATION (STATIC/TT200) ---

  public generateFromSales(order: SalesOrder): AccountingEntry[] {
    const entries: AccountingEntry[] = [];
    const revenue = order.pricing.gdbPriceTotal;
    const vat = order.pricing.taxAmount;
    const total = order.pricing.totalAmount;
    const cogs = order.pricing.costOfGoods;

    // 1. REVENUE (Nợ 131 / Có 511 / Có 3331)
    entries.push(this.createEntry(`ACC-REV-${order.orderId}`, 'REVENUE', `Doanh thu đơn ${order.orderId}`, [
      { accountNumber: '131', accountName: SmartLinkEngine.COA['131'], debit: total, credit: 0, currency: 'VND', detail: `Phải thu ${order.customer.name}` },
      { accountNumber: '511', accountName: SmartLinkEngine.COA['511'], debit: 0, credit: revenue, currency: 'VND' },
      { accountNumber: '3331', accountName: SmartLinkEngine.COA['3331'], debit: 0, credit: vat, currency: 'VND' }
    ], order.orderId));

    // 2. COGS (Nợ 632 / Có 156)
    entries.push(this.createEntry(`ACC-COGS-${order.orderId}`, 'COGS', `Giá vốn đơn ${order.orderId}`, [
      { accountNumber: '632', accountName: SmartLinkEngine.COA['632'], debit: cogs, credit: 0, currency: 'VND' },
      { accountNumber: '156', accountName: SmartLinkEngine.COA['156'], debit: 0, credit: cogs, currency: 'VND' }
    ], order.orderId));

    return entries;
  }

  public generateFromBank(tx: BankTransaction): AccountingEntry {
    const isIncome = (tx.credit && tx.credit > 0) || (tx.amount && tx.amount > 0);
    const amount = tx.credit || tx.amount || 0;
    const debitAcc = isIncome ? '112' : '642';
    const creditAcc = isIncome ? '131' : '112';

    return this.createEntry(`ACC-BNK-${tx.id}`, undefined, tx.description, [
      { accountNumber: debitAcc, accountName: SmartLinkEngine.COA[debitAcc], debit: amount, credit: 0, currency: 'VND' },
      { accountNumber: creditAcc, accountName: SmartLinkEngine.COA[creditAcc], debit: 0, credit: amount, currency: 'VND' }
    ], tx.id);
  }

  private createEntry(id: string, type: any, desc: string, lines: any[], reference: string): AccountingEntry {
    return {
      
      transactionDate: Date.now(),
      description: desc,
      journalType: type,
      status: 'DRAFT',
      entries: lines,
      reference: "refId",
      // Added matchScore to satisfy AccountingEntry interface
      matchScore: 100,
      createdAt: new Date()
    };
  }
}

export const SmartLinkCore = SmartLinkEngine.getInstance();
### src/components/seller-terminal.tsx ###

import React, { useState, useMemo, useEffect } from 'react';
import { UserRole, UserPosition, PositionType, SellerReport, SellerIdentity, CustomerLead, PersonaID } from '@/types';
import { SellerEngine } from '@/services/sellerengine';
import { NotifyBus } from '@/services/notificationservice';

interface SellerTerminalProps {
  currentRole: UserRole;
  currentPosition: UserPosition;
  logAction: (action: string, details: string) => void;
}

const SellerTerminal: React.FC<SellerTerminalProps> = ({ currentRole, currentPosition, logAction }) => {
  const [activeTab, setActiveTab] = useState<'DASHBOARD' | 'leads' | 'order_engine' | 'manager_hub' | 'hidebox'>('DASHBOARD');
  const [reports, setReports] = useState<SellerReport[]>([]);
  const [leads, setLeads] = useState<CustomerLead[]>([
     { id: 'L-001', name: 'NGUYỄN VĂN A', phone: '0901234567', source: 'Facebook Ads', ownerId: 'S-007', assignedDate: Date.now() - (10 * 86400000), expiryDate: Date.now() + (80 * 86400000), status: 'WARM', lastInteraction: Date.now() },
     { id: 'L-002', name: 'TRẦN THỊ B', phone: '0918888999', source: 'Giới thiệu', ownerId: 'S-007', assignedDate: Date.now() - (85 * 86400000), expiryDate: Date.now() + (5 * 86400000), status: 'HOT', lastInteraction: Date.now() - 86400000 },
     { id: 'L-003', name: 'LÊ VĂN C', phone: '0909000111', source: 'Zalo', ownerId: 'S-007', assignedDate: Date.now() - (70 * 86400000), expiryDate: Date.now() + (20 * 86400000), status: 'COLD', lastInteraction: Date.now() - (8 * 86400000) } // Inactive > 7 days
  ]);
  
  const [me] = useState<SellerIdentity>({
    userId: 'S-007',
    // Fix: currentPosition is an object, access its .role property for comparison
    fullName: currentPosition.role === PositionType.COLLABORATOR ? 'CTV Nguyễn Văn A' : 'Seller Lê Trọng Khôi',
    stars: 4,
    kpiPoints: 105,
    violations: 0,
    role: currentRole,
    position: currentPosition,
    // Fix: currentPosition is an object, access its .role property for comparison
    isCollaborator: currentPosition.role === PositionType.COLLABORATOR,
    department: 'KINH_DOANH',
    gatekeeperBalance: 500000
  });

  const [formData, setFormData] = useState({
    customer: '',
    phone: '',
    sku: '',
    shellVal: 0,
    stoneVal: 0,
    stoneType: 'NONE' as any
  });
  const [simulatedComm, setSimulatedComm] = useState<any>(null);

  const [hideBoxMsg, setHideBoxMsg] = useState('');
  const isManager = currentRole === UserRole.SENIOR_STAFF || currentRole === UserRole.STAFF;

  useEffect(() => {
    if (formData.shellVal > 0 || formData.stoneVal > 0) {
      const comm = SellerEngine.calculateCommission({
        shellRevenue: formData.shellVal,
        stoneRevenue: formData.stoneVal,
        stoneType: formData.stoneType,
        isReportedWithin24h: true
      }, me.kpiPoints);
      setSimulatedComm(comm);
    } else {
      setSimulatedComm(null);
    }
  }, [formData, me.kpiPoints]);

  const handleSubmitReport = () => {
    const commission = SellerEngine.calculateCommission({
      shellRevenue: formData.shellVal,
      stoneRevenue: formData.stoneVal,
      stoneType: formData.stoneType,
      isReportedWithin24h: SellerEngine.check24hRule(Date.now())
    }, me.kpiPoints);

    const newReport: SellerReport = {
      id: `REP-${Date.now()}`,
      sellerId: me.userId,
      sellerName: me.fullName,
      customerName: formData.customer,
      customerPhone: formData.phone,
      productSku: formData.sku,
      shellRevenue: formData.shellVal,
      stoneRevenue: formData.stoneVal,
      stoneType: formData.stoneType,
      depositAmount: 0,
      isReportedWithin24h: SellerEngine.check24hRule(Date.now()),
      status: 'PENDING',
      documents: {},
      commission,
      timestamp: Date.now()
    };

    setReports([newReport, ...reports]);
    logAction('SELLER_REPORT_SUBMIT', `Báo cáo đơn ${formData.sku} - Hoa hồng: ${commission.total.toLocaleString()}đ`);
    
    const lead = leads.find(l => l.phone === formData.phone);
    if (lead) {
       setLeads(prev => prev.map(l => l.id === lead.id ? { ...l, status: 'CONVERTED' } : l));
    }

    setActiveTab('DASHBOARD');
    NotifyBus.push({ type: 'SUCCESS', title: 'Đã ghi nhận đơn hàng', content: `Hoa hồng tạm tính: ${commission.total.toLocaleString()} đ`, persona: PersonaID.CAN });
  };

  const handlePhieuSuggestion = async () => {
    const newLead: CustomerLead = {
      id: `L-AI-${Date.now()}`,
      name: 'KHÁCH HÀNG TIỀM NĂNG (AI)',
      phone: '09xxxxxxxxx',
      source: 'Phiêu Suggestion',
      ownerId: me.userId,
      assignedDate: Date.now(),
      expiryDate: Date.now() + (90 * 86400000),
      status: 'WARM',
      lastInteraction: Date.now()
    };
    setLeads([newLead, ...leads]);
    NotifyBus.push({ type: 'NEWS', title: 'Phiêu: New Lead', content: 'Đã phân bổ 01 Lead từ kho chung cho bạn.', persona: PersonaID.PHIEU });
  };

  const totalCommission = useMemo(() => reports.reduce((s, r) => s + r.commission.total, 0), [reports]);

  return (
    <div className="h-full flex flex-col bg-[#050505] p-8 md:p-12 overflow-y-auto no-scrollbar gap-10 animate-in fade-in duration-700 pb-32">
      <header className="flex flex-col md:flex-row justify-between items-end gap-6 border-b border-white/5 pb-10">
        <div>
          <div className="flex items-center gap-4 mb-2">
             <span className="text-4xl">💼</span>
             <h2 className="ai-headline text-5xl italic uppercase tracking-tighter">
               {me.isCollaborator ? 'CTV HUB' : 'SELLER TERMINAL'}
             </h2>
          </div>
          <p className="ai-sub-headline text-indigo-300/40 mt-1 italic uppercase font-black tracking-[0.3em]">
             {me.isCollaborator ? 'Cộng tác viên (0 Lương cứng) • Hoa hồng 100%' : 'Nhân viên kinh doanh • Lương cứng + Hoa hồng'}
          </p>
        </div>
        
        <div className="flex gap-4">
           <div className="ai-panel px-6 py-3 border-amber-500/20 bg-amber-500/5 text-center">
              <p className="text-[8px] text-amber-500 font-black uppercase mb-1">Xếp hạng Node</p>
              <div className="flex gap-1 justify-center">
                 {Array.from({ length: me.stars }).map((_, i) => <span key={i} className="text-xs">⭐</span>)}
              </div>
              <p className="text-[9px] text-gray-500 mt-1 font-mono">{me.kpiPoints} KPI pts</p>
           </div>
           <div className="ai-panel px-6 py-3 border-green-500/20 bg-green-500/5 text-center">
              <p className="text-[8px] text-green-400 font-black uppercase mb-1">Thu nhập (Commission)</p>
              <p className="text-xl font-mono font-black text-white">{totalCommission.toLocaleString()} <span className="text-xs">đ</span></p>
           </div>
        </div>
      </header>

      <nav className="flex bg-black/40 p-1.5 rounded-2xl border border-white/10 w-fit sHRink-0 overflow-x-auto no-scrollbar">
        <button onClick={() => setActiveTab('DASHBOARD')} className={`px-8 py-3 rounded-xl text-[10px] font-black uppercase transition-all whitespace-nowrap ${activeTab === 'DASHBOARD' ? 'bg-amber-500 text-black shadow-lg' : 'text-gray-500 hover:text-white'}`}>Tổng quan & Thu nhập</button>
        <button onClick={() => setActiveTab('leads')} className={`px-8 py-3 rounded-xl text-[10px] font-black uppercase transition-all whitespace-nowrap ${activeTab === 'leads' ? 'bg-blue-600 text-white shadow-lg' : 'text-gray-500 hover:text-white'}`}>Timeline Lead (90 Ngày)</button>
        <button onClick={() => setActiveTab('order_engine')} className={`px-8 py-3 rounded-xl text-[10px] font-black uppercase transition-all whitespace-nowrap ${activeTab === 'order_engine' ? 'bg-indigo-600 text-white shadow-lg' : 'text-gray-500 hover:text-white'}`}>Tạo Đơn & Tính HH</button>
        {isManager && <button onClick={() => setActiveTab('manager_hub')} className={`px-8 py-3 rounded-xl text-[10px] font-black uppercase transition-all whitespace-nowrap ${activeTab === 'manager_hub' ? 'bg-purple-600 text-white shadow-lg' : 'text-gray-500 hover:text-white'}`}>Quản Lý Team</button>}
        <button onClick={() => setActiveTab('hidebox')} className={`px-8 py-3 rounded-xl text-[10px] font-black uppercase transition-all whitespace-nowrap ${activeTab === 'hidebox' ? 'bg-white/10 text-white' : 'text-gray-500 hover:text-white'}`}>HideBox (Ẩn danh)</button>
      </nav>

      <main className="flex-1">
        {activeTab === 'DASHBOARD' && (
          <div className="space-y-8 animate-in fade-in">
             <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div className="ai-panel p-8 bg-green-500/5 border-green-500/20">
                   <p className="ai-sub-headline text-green-400">HH Vỏ (5%)</p>
                   <p className="text-3xl font-mono font-black text-white mt-2">{(reports.reduce((s, r) => s + r.commission.shell, 0)).toLocaleString()} <span className="text-xs">đ</span></p>
                </div>
                <div className="ai-panel p-8 bg-blue-500/5 border-blue-500/20">
                   <p className="ai-sub-headline text-blue-400">HH Viên (2-5%)</p>
                   <p className="text-3xl font-mono font-black text-white mt-2">{(reports.reduce((s, r) => s + r.commission.stone, 0)).toLocaleString()} <span className="text-xs">đ</span></p>
                </div>
                <div className="ai-panel p-8 bg-amber-500/10 border-amber-500/20 md:col-span-2 relative overflow-hidden">
                   <div className="relative z-10">
                      <p className="ai-sub-headline text-amber-500">Tổng thực lãnh (Sau Gatekeeper)</p>
                      <p className="text-4xl font-mono font-black text-white mt-2">{totalCommission.toLocaleString()} <span className="text-xs">VND</span></p>
                   </div>
                   <div className="absolute top-0 right-0 p-4 opacity-10 text-6xl">💰</div>
                </div>
             </div>
          </div>
        )}
      </main>
    </div>
  );
};

export default SellerTerminal;

### src/components/system-monitor.tsx ###
/**
 * 👑 NATT-OS GOLD ADMIN: SYSTEM MONITORING CORE
 * AUTHORIZED BY: ANH_NAT (SOVEREIGN)
 * STATUS: 100% CONSTITUTIONAL | 0 ERRORS
 */

import React, { useState, useEffect, useRef } from 'react';
import {
  Activity, ShieldCheck, Zap, Server,
  RotateCcw, Eye
} from 'lucide-react';
// Import từ Shared Kernel (Điều 7)
import { BusinessMetrics, PersonaID, OperationRecord } from '@/types';
import THReatDetectionService, { SecurityTHReat, SystemHealth } from '@/services/threatdetectionservice';
import { RecoverySystem } from '@/services/recoveryengine';
import { NotifyBus } from '@/services/notificationservice';

interface SystemMonitorProps {
  logAction?: (action: string, details: string) => void;
  metrics?: BusinessMetrics;
}

interface ModuleStatus {
  id: string;
  name: string;
  status: 'OPTIMAL' | 'WARNING' | 'CRITICAL' | 'OFFLINE';
  latency: number;
  uptime: number;
  lastError?: string;
}

const SystemMonitor: React.FC<SystemMonitorProps> = () => {
  const [activeTab, setActiveTab] = useState<'HEALTH' | 'SECURITY'>('HEALTH');
  const [isScanning, setIsScanning] = useState(false);
  const [scanLogs, setScanLogs] = useState<string[]>([]);
  const [modules, setModules] = useState<ModuleStatus[]>([]);
  const [scanProgress, setScanProgress] = useState(0);
  const [, setDeadLetter] = useState<OperationRecord[]>([]);
  
  const [, setTHReats] = useState<SecurityTHReat[]>([]);
  const [healthMetrics, setHealthMetrics] = useState<SystemHealth>(THReatDetectionService.getHealth());

  const logContainerRef = useRef<HTMLDivElement>(null);

  // Khởi tạo Long Mạch (30 Nodes)
  useEffect(() => {
    const getModuleName = (index: number) => {
      const names = [
        'Finance Core', 'Sales Engine', 'Inventory Shard', 'HR Ledger', 'Logistics API',
        'Tax Gateway', 'Audit Trail', 'User Auth', 'Notification Bus', 'AI Neural Net',
        'Payment Node', 'Customs Robot', 'Production Flow', 'Design Vault', 'Backup Service'
      ];
      return names[index] || `Sub-Node ${index + 1}`;
    };

    const initialModules: ModuleStatus[] = Array.from({ length: 30 }).map((_, i) => ({
      id: `MOD-${String(i + 1).padStart(2, '0')}`,
      name: getModuleName(i),
      status: 'OPTIMAL',
      latency: Math.floor(Math.random() * 50) + 10,
      uptime: 99.9
    }));

    setModules(initialModules);
    setDeadLetter(RecoverySystem.getDeadLetterQueue());

    const unsubTHReats = THReatDetectionService.subscribe((tHReat) => {
      setTHReats(prev => [tHReat, ...prev].slice(0, 50));
    });

    const interval = setInterval(() => {
      setHealthMetrics(THReatDetectionService.getHealth());
    }, 2000);

    return () => {
      unsubTHReats();
      clearInterval(interval);
    };
  }, []);

  useEffect(() => {
    if (logContainerRef.current) {
      logContainerRef.current.scrollTop = logContainerRef.current.scrollHeight;
    }
  }, [scanLogs]);

  const addLog = (msg: string, type: 'INFO' | 'WARN' | 'ERR' | 'SUCCESS' = 'INFO') => {
    const time = new Date().toLocaleTimeString();
    setScanLogs(prev => [...prev, `[${time}] [${type}] ${msg}`]);
  };

  const runDeepScan = async () => {
    if (isScanning) return;
    setIsScanning(true);
    setScanLogs([]);
    setScanProgress(0);
    
    addLog("BẮT ĐẦU CHIẾN DỊCH DEEP SCAN LÕI OMEGA v9.2...", "INFO");
    addLog("Đang thiết lập kết nối Shard-to-Shard...", "INFO");

    const total = modules.length;
    for (let i = 0; i < total; i++) {
      const mod = modules[i];
      await new Promise(r => setTimeout(r, 40 + Math.random() * 80));
      setScanProgress(Math.round(((i + 1) / total) * 100));

      const rand = Math.random();
      let newStatus: ModuleStatus['status'] = 'OPTIMAL';
      let errorMsg: string | undefined = undefined;

      if (rand > 0.94) {
        newStatus = 'CRITICAL';
        errorMsg = 'SHARD_CORRUPTION';
        addLog(`PHÁT HIỆN CRASH TẠI ${mod.name}: ${errorMsg}`, "ERR");
        RecoverySystem.recordOperation('REPAIR_NODE', mod.name, { nodeId: mod.id });
      } else if (rand > 0.88) {
        newStatus = 'WARNING';
        errorMsg = 'LATENCY_SPIKE';
        addLog(`Cảnh báo tại ${mod.name}: Hiệu suất suy giảm`, "WARN");
      } else {
        addLog(`Xác thực ${mod.name}: OK`, "INFO");
      }

      setModules(prev => prev.map(m => m.id === mod.id ? { ...m, status: newStatus, lastError: errorMsg } : m));
    }

    setDeadLetter(RecoverySystem.getDeadLetterQueue());
    addLog("QUÉT SÂU HOÀN TẤT. ĐÃ PHÂN TÁCH CÁC NODE LỖI.", "SUCCESS");
    setIsScanning(false);

    if (modules.some(m => m.status === 'CRITICAL')) {
      NotifyBus.push({
        type: 'RISK',
        title: 'HỆ THỐNG CÓ LỖI CRITICAL',
        content: 'Phát hiện Shard bị Crash. Anh Natt hãy thực hiện AUTO-FIX ngay.',
        persona: PersonaID.THIEN,
        priority: 'HIGH'
      });
    }
  };

  const handleFixAll = async () => {
    addLog("KÍCH HOẠT GIAO THỨC AUTO-FIX TOÀN HỆ THỐNG...", "WARN");
    setIsScanning(true);
    
    const crashed = modules.filter(m => m.status === 'CRITICAL');
    for (const mod of crashed) {
      addLog(`Đang phục hồi Shard: ${mod.name}...`, "INFO");
      await new Promise(r => setTimeout(r, 1000));
      setModules(prev => prev.map(m => m.id === mod.id ? { ...m, status: 'OPTIMAL', lastError: undefined } : m));
      addLog(`✓ Phục hồi thành công: ${mod.name}`, "SUCCESS");
    }

    setDeadLetter([]);
    addLog("MỌI MODULE ĐÃ ĐƯỢC ĐƯA VỀ TRẠNG THÁI NOMINAL.", "SUCCESS");
    setIsScanning(false);
  };

  const crashedCount = modules.filter(m => m.status === 'CRITICAL').length;

  // Mini Sparkline UI Helper
  const MiniSparkline: React.FC<{ color: string }> = ({ color }) => (
    <div className="flex items-end gap-0.5 h-8 w-full mt-2">
      {Array.from({ length: 10 }).map((_, i) => (
        <div key={i} className={`flex-1 rounded-sm ${color}`} style={{ height: `${20 + Math.random() * 80}%`, opacity: 0.6 + (i / 20) }} />
      ))}
    </div>
  );

  return (
    <div className="h-full flex flex-col bg-[#020202] p-8 md:p-12 overflow-y-auto no-scrollbar gap-10 animate-in fade-in duration-700 pb-40">
      {/* HEADER */}
      <header className="flex justify-between items-end border-b border-white/5 pb-10">
        <div>
          <div className="flex items-center space-x-3 mb-2">
            <span className={`px-2 py-0.5 text-white text-[8px] font-black rounded uppercase tracking-widest ${crashedCount > 0 ? 'bg-red-600 animate-pulse' : 'bg-green-600'}`}>
              {crashedCount > 0 ? `SYSTEM ALERT: ${crashedCount} CRASHES` : 'SYSTEM NOMINAL'}
            </span>
            <h2 className="ai-headline text-5xl italic tracking-tighter uppercase leading-none">System Pulse</h2>
          </div>
          <p className="ai-sub-headline text-indigo-300/40 font-black tracking-[0.3em]">Master Control • Sovereign: ANH_NAT</p>
        </div>
        
        <div className="flex items-center gap-6">
          <div className="flex bg-white/5 p-1 rounded-2xl border border-white/10">
            <button onClick={() => setActiveTab('HEALTH')} className={`px-6 py-2 rounded-xl text-[10px] font-black uppercase transition-all ${activeTab === 'HEALTH' ? 'bg-amber-500 text-black shadow-lg' : 'text-gray-500 hover:text-white'}`}>Health</button>
            <button onClick={() => setActiveTab('SECURITY')} className={`px-6 py-2 rounded-xl text-[10px] font-black uppercase transition-all ${activeTab === 'SECURITY' ? 'bg-red-600 text-white shadow-lg' : 'text-gray-500 hover:text-white'}`}>Security</button>
          </div>
          {crashedCount > 0 && (
            <button onClick={handleFixAll} className="px-8 py-3 bg-green-600 text-white font-black text-[10px] uppercase rounded-xl shadow-xl hover:bg-green-500 animate-bounce">
              🚀 AUTO-FIX ALL
            </button>
          )}
        </div>
      </header>

      {/* BODY GRID */}
      <div className="grid grid-cols-1 xl:grid-cols-3 gap-10">
        {/* TERMINAL */}
        <div className="ai-panel p-0 bg-black border-white/10 relative overflow-hidden flex flex-col h-[500px]">
          <div className="p-4 bg-white/5 border-b border-white/5 flex justify-between items-center">
            <span className="text-[10px] font-mono text-gray-400">{" >> "} root@natt-os:~# deep_scan_v9.sh</span>
            <div className="flex gap-2">
              <div className="w-2 h-2 rounded-full bg-red-500" />
              <div className="w-2 h-2 rounded-full bg-amber-500" />
              <div className="w-2 h-2 rounded-full bg-green-500" />
            </div>
          </div>
          <div ref={logContainerRef} className="flex-1 p-6 overflow-y-auto no-scrollbar font-mono text-[10px] space-y-1.5">
            {scanLogs.length === 0 && <span className="text-gray-600 italic">Hệ thống đang chờ lệnh...</span>}
            {scanLogs.map((log, i) => (
              <p key={i} className={log.includes('[ERR]') ? 'text-red-500' : log.includes('[WARN]') ? 'text-amber-500' : 'text-gray-400'}>{log}</p>
            ))}
            {isScanning && <div className="w-2 h-4 bg-green-500 animate-pulse inline-block ml-1" />}
          </div>
        </div>

        {/* MODULE GRID */}
        <div className="xl:col-span-2 ai-panel p-10 bg-black/40 border-indigo-500/20 shadow-2xl relative flex flex-col">
          <div className="flex justify-between items-center mb-8">
            <h3 className="text-sm font-black text-indigo-400 uppercase tracking-[0.4em] flex items-center gap-4">
              <span className="w-2 h-2 bg-indigo-400 rounded-full animate-ping" />
              Omega Shard Grid
            </h3>
            {!isScanning && <button onClick={runDeepScan} className="px-6 py-2 bg-amber-500 text-black font-black text-[9px] uppercase rounded-xl">KÍCH HOẠT DEEP SCAN</button>}
          </div>

          <div className="grid grid-cols-2 md:grid-cols-5 gap-4 overflow-y-auto no-scrollbar flex-1">
            {modules.map((m) => (
              <div key={m.id} className={`p-4 rounded-2xl border transition-all flex flex-col items-center gap-2 ${m.status === 'CRITICAL' ? 'border-red-500 bg-red-500/10' : 'border-white/5 bg-white/[0.02]'}`}>
                <div className={`w-8 h-8 rounded-lg flex items-center justify-center text-lg ${m.status === 'CRITICAL' ? 'bg-red-500' : 'bg-white/5'}`}>
                  {m.status === 'CRITICAL' ? '⚠️' : '⚡'}
                </div>
                <p className="text-[9px] font-black uppercase truncate w-full text-center text-gray-400">{m.name}</p>
                <p className="text-[7px] font-mono text-gray-600">{m.latency}ms</p>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* FOOTER: LONG MACH REPORT */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-10">
        <div className="lg:col-span-2 glass p-10 rounded-[3.5rem] border border-white/5 bg-gradient-to-br from-purple-500/5 to-transparent">
          <h3 className="text-2xl font-bold mb-6 flex items-center italic text-white">
            <span className="mr-4 text-3xl">📡</span> Báo cáo Long Mạch Shard
          </h3>
          <div className="space-y-4">
            {[
              { name: 'Node Phân Phối HCM', status: 'ACTIVE' },
              { name: 'Node In sáp 4K', status: 'ACTIVE' },
              { name: 'Cổng Thuế Direct API', status: 'STABLE' },
              { name: 'Shard Kế Toán 2024', status: crashedCount > 0 ? 'CORRUPTED' : 'NOMINAL' }
            ].map((node, i) => (
              <div key={i} className="p-6 bg-black/40 rounded-3xl border border-white/10 flex justify-between items-center">
                <div className="flex items-center space-x-8">
                  <div className={`w-3 h-3 rounded-full ${node.status === 'CORRUPTED' ? 'bg-red-500 animate-pulse' : 'bg-cyan-500'}`} />
                  <div>
                    <p className="text-white font-bold text-sm uppercase">{node.name}</p>
                    <p className="text-[9px] text-gray-500 uppercase font-black">Status: {node.status}</p>
                  </div>
                </div>
                <span className="text-cyan-400 text-[9px] font-black uppercase bg-cyan-400/5 px-4 py-1.5 rounded-full">{node.status}</span>
              </div>
            ))}
          </div>
        </div>

        {/* AI ADVISORY */}
        <div className="ai-panel p-8 bg-black/40 border-amber-500/20 flex flex-col items-center text-center">
          <h4 className="ai-sub-headline text-amber-500 mt-6 mb-4">Phiêu: Chẩn đoán</h4>
          <p className="text-[12px] text-gray-400 italic leading-relaxed">
            {isScanning
              ? "Phiêu đang len lỏi vào từng Shard. Anh Natt chờ xíu nhé..."
              : crashedCount > 0
                ? `Phát hiện ${crashedCount} Shard rò rỉ dữ liệu. Phiêu đã chuẩn bị sẵn Backup. Hãy nhấn 'AUTO-FIX' ngay.`
                : "Hệ thống đang ở trạng thái mượt mà nhất. Mọi Long Mạch Shard đều thông suốt."}
          </p>
        </div>
      </div>
    </div>
  );
};

export default SystemMonitor;

### src/components/master-dashboard.tsx ###

import React, { useState, useEffect } from 'react';
import { HUDMetric, UserRole, UserPosition, PersonaID, Department } from '@/cells/shared-kernel/shared.types';
// FIX: Corrected import path to use kebab-case smart-link.ts
import { SmartLinkClient } from '@/services/smart-link';
import LoadingSpinner from './common/loading-spinner';
import { ShieldCheck, Fingerprint, Database } from 'lucide-react';

const MasterDashboard: React.FC<{ currentRole: UserRole, currentPosition: UserPosition }> = ({ currentRole, currentPosition }) => {
  const [metrics, setMetrics] = useState<HUDMetric[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const syncNeuralNodes = async () => {
      setIsLoading(true);
      try {
        const WAREHOUSEEnv = SmartLinkClient.createEnvelope('cell:WAREHOUSE', 'GetInventoryStats', {});
        const salesEnv = SmartLinkClient.createEnvelope('cell:sales', 'GetRevenueStats', {});
        
        const [WAREHOUSEData, revenue] = await Promise.all([
          SmartLinkClient.send(WAREHOUSEEnv),
          SmartLinkClient.send(salesEnv)
        ]);

        setMetrics([
          {
            id: 'M1', name: 'DOANH THU CHỐT SHARD', value: revenue || 449120, unit: 'VND',
            trend: { direction: 'UP', percentage: 100, isPositive: true },
            department: Department.SALES, icon: '💰'
          },
          {
            id: 'M2', name: 'TỒN KHO CELL', value: WAREHOUSEData.total_items || 0, unit: 'SP',
            trend: { direction: 'STABLE', percentage: 0, isPositive: true },
            department: Department.HEADQUARTER, icon: '📦'
          }
        ]);
      } finally {
        setIsLoading(false);
      }
    };
    syncNeuralNodes();
  }, []);

  if (isLoading) return <LoadingSpinner message="Re-tHReading Neural Fiber via SmartLink..." />;

  return (
    <div className="h-full flex flex-col p-12 bg-transparent pb-60 animate-in fade-in">
      <header className="mb-16 flex justify-between items-start">
          <div>
            <h1 className="text-7xl font-black tracking-tighter text-white italic uppercase leading-none">NATT-OS CORE</h1>
            <p className="text-stone-500 text-xl font-light italic mt-4">Sovereign DNA Integrated • Gold Master v1.1</p>
          </div>
          <div className="flex gap-4">
             <div className="bg-red-600/10 border border-red-500/30 p-6 rounded-[2rem] flex items-center gap-4 shadow-2xl">
                <div className="w-12 h-12 rounded-xl bg-red-600 flex items-center justify-center text-white">
                   <Fingerprint size={28} />
                </div>
                <div>
                   <p className="text-[10px] text-red-500 font-black uppercase tracking-widest">DNA Sealing Status</p>
                   <p className="text-xl font-mono text-white font-bold">128/128 <span className="text-sm text-gray-600">SHARDS</span></p>
                </div>
             </div>
          </div>
      </header>

      <section className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-12">
           {metrics.map(m => (
               <div key={m.id} className="ai-panel p-10 bg-[#121212] rounded-[32px] border border-white/5 group hover:border-amber-500/30 transition-all">
                  <span className="text-[10px] font-black text-stone-600 uppercase tracking-widest">{m.name}</span>
                  <p className="text-5xl font-mono font-black text-white italic mt-4">{m.value.toLocaleString()} <span className="text-sm not-italic text-stone-500">{m.unit}</span></p>
               </div>
           ))}
           <div className="ai-panel p-10 bg-green-500/5 border-green-500/20 rounded-[32px] flex flex-col justify-between">
              <div className="flex justify-between items-start">
                 <span className="text-[10px] font-black text-green-500 uppercase tracking-widest">Integrity Lock</span>
                 <ShieldCheck className="text-green-500" size={20} />
              </div>
              <p className="text-2xl font-bold text-white uppercase italic leading-tight mt-4">Verified by<br/>Anh Nat</p>
           </div>
      </section>

      <div className="mt-20 grid grid-cols-1 lg:grid-cols-12 gap-12 items-start">
         <div className="lg:col-span-4">
         </div>
         <div className="lg:col-span-8 p-12 bg-white/[0.02] rounded-[48px] italic font-light text-stone-400 text-2xl border border-white/5 relative overflow-hidden group">
            <div className="absolute top-0 right-0 p-8 opacity-5">
               <Database size={120} />
            </div>
            "Báo cáo Master: Toàn bộ 128 tệp tin đã được cấy ADN định danh. Hệ thống đã đạt trạng thái **ABSOLUTE_OWNERSHIP** thuộc về Anh Nat."
         </div>
      </div>
    </div>
  );
};

export default MasterDashboard;

### src/components/sales-tax-module.tsx ###

import React, { useState, useEffect } from 'react';
import { EInvoice, EInvoiceStatus, BusinessMetrics, UserRole, PersonaID, EInvoiceItem } from '@/types';
import { EInvoiceEngine } from '@/services/einvoiceservice';
import { NotifyBus } from '@/services/notificationservice';
import { FileCode, ShieldCheck, Send, CheckCircle2, Receipt, Cpu, Database, ChevronRight, Zap } from 'lucide-react';

interface SalesTaxModuleProps {
  logAction: (action: string, details: string) => void;
  metrics: BusinessMetrics;
  currentRole: UserRole;
}

const SalesTaxModule: React.FC<SalesTaxModuleProps> = ({ logAction, metrics, currentRole }) => {
  const [invoices, setInvoices] = useState<EInvoice[]>([]);
  const [selectedInvoice, setSelectedInvoice] = useState<EInvoice | null>(null);
  const [isProcessing, setIsProcessing] = useState(false);
  const [viewMode, setViewMode] = useState<'LEDGER' | 'WORKBENCH'>('LEDGER');

  useEffect(() => {
    // Khởi tạo một số hóa đơn mẫu để bóc tách
    const mockItems: EInvoiceItem[] = [
      { id: 'it1', name: 'Nhẫn Nam Rolex 18K', goldWeight: 3.5, goldPrice: 24000000, stonePrice: 350000000, laborPrice: 5000000, taxRate: 10, totalBeforeTax: 379000000 }
    ];
    
    const initialInv: EInvoice = {
      id: 'INV-2026-0001',
      orderId: 'ORD-9988',
      customerName: 'ANH NATT ADMIN',
      items: mockItems,
      totalAmount: 379000000,
      taxAmount: 37900000,
      vatRate: 10,
      status: EInvoiceStatus.DRAFT,
      createdAt: Date.now()
    };
    setInvoices([initialInv]);
  }, []);

  const handleSignInvoice = async (inv: EInvoice) => {
    setIsProcessing(true);
    try {
      // 1. Tạo XML
      const xml = EInvoiceEngine.generateXML(inv);
      inv.xmlPayload = xml;
      inv.status = EInvoiceStatus.XML_BUILT;
      
      await new Promise(r => setTimeout(r, 1000));
      
      // 2. Ký số (Simulated Token)
      const signature = await EInvoiceEngine.signInvoice(inv.id);
      inv.signatureHash = signature;
      inv.status = EInvoiceStatus.SIGNED;
      
      logAction('FISCAL_SIGN', `Đã ký số hóa đơn ${inv.id} chuẩn RSA-4096.`);
      
      // 3. Truyền tin lên TCT
      const result = await EInvoiceEngine.transmitToTaxAuthority(inv);
      if (result.success) {
          inv.status = EInvoiceStatus.ACCEPTED;
          inv.taxCode = result.taxCode;
          inv.issuedAt = Date.now();
          NotifyBus.push({
            type: 'SUCCESS',
            title: 'Hóa đơn đã được niêm phong TCT',
            content: `Mã CQT: ${inv.taxCode} đã được băm vào sổ cái.`,
            persona: PersonaID.CAN
          });
      }
    } finally {
      setIsProcessing(false);
      setInvoices([...invoices]);
    }
  };

  return (
    <div className="h-full flex flex-col p-8 lg:p-12 overflow-hidden gap-8 bg-[#020202] animate-in fade-in duration-700">
      <header className="flex justify-between items-end border-b border-white/5 pb-8">
        <div>
          <div className="flex items-center gap-4">
             <span className="px-3 py-1 bg-amber-500/20 text-amber-500 text-[10px] font-black rounded-full border border-amber-500/30 uppercase tracking-widest">Self-Built Node v5.2</span>
             <h2 className="ai-headline text-5xl italic uppercase tracking-tighter text-white">Fiscal Terminal</h2>
          </div>
          <p className="ai-sub-headline text-stone-500 font-black uppercase tracking-[0.4em] mt-2">Bóc tách dòng hàng • Ký số RSA • Truyền tin Direct API</p>
        </div>
        
        <div className="flex bg-black/60 p-4 rounded-3xl border border-white/5 shadow-2xl">
            <div className="text-right">
                <p className="text-[9px] text-stone-600 uppercase font-black">Digital Token Status</p>
                <p className="text-sm font-black text-green-500 uppercase italic">SafeCA Online</p>
            </div>
        </div>
      </header>

      <div className="flex gap-4 mb-2">
         <button onClick={() => setViewMode('LEDGER')} className={`px-8 py-3 rounded-2xl text-[10px] font-black uppercase tracking-widest transition-all ${viewMode === 'LEDGER' ? 'bg-amber-500 text-black shadow-lg' : 'bg-white/5 text-stone-500'}`}>1. Sổ cái hóa đơn</button>
         <button onClick={() => setViewMode('WORKBENCH')} className={`px-8 py-3 rounded-2xl text-[10px] font-black uppercase tracking-widest transition-all ${viewMode === 'WORKBENCH' ? 'bg-amber-500 text-black shadow-lg' : 'bg-white/5 text-stone-500'}`}>2. Bóc tách XML (Workbench)</button>
      </div>

      <main className="flex-1 grid grid-cols-1 xl:grid-cols-12 gap-8 min-h-0">
         {/* LEFT: CONTENT AREA */}
         <div className="xl:col-span-8 ai-panel overflow-hidden border-white/5 bg-black/40 flex flex-col shadow-2xl">
            {viewMode === 'LEDGER' ? (
               <div className="flex-1 overflow-y-auto no-scrollbar">
                  <table className="w-full text-left text-[11px] border-collapse">
                     <thead>
                        <tr className="text-stone-500 font-black uppercase tracking-widest border-b border-white/10 bg-black sticky top-0 z-10">
                           <th className="p-6">Mã Hóa Đơn / Khách hàng</th>
                           <th className="p-6 text-right">Tổng giá trị (Net)</th>
                           <th className="p-6 text-center">Trạng thái Shard</th>
                           <th className="p-6 text-right">Tác vụ</th>
                        </tr>
                     </thead>
                     <tbody className="text-stone-300">
                        {invoices.map(inv => (
                          <tr key={inv.id} className={`border-b border-white/5 hover:bg-white/[0.02] transition-colors cursor-pointer ${selectedInvoice?.id === inv.id ? 'bg-white/[0.05]' : ''}`} onClick={() => setSelectedInvoice(inv)}>
                             <td className="p-6">
                                <p className="font-bold text-white uppercase">{inv.id}</p>
                                <p className="text-[9px] text-stone-600 font-mono mt-1">{inv.customerName}</p>
                             </td>
                             <td className="p-6 text-right font-mono font-black text-lg text-white">
                                {(inv.totalAmount + inv.taxAmount).toLocaleString()} đ
                             </td>
                             <td className="p-6 text-center">
                                <span className={`px-3 py-1 rounded-full text-[8px] font-black uppercase border ${
                                    inv.status === EInvoiceStatus.ACCEPTED ? 'bg-green-600/10 text-green-500 border-green-500/30' : 
                                    inv.status === EInvoiceStatus.SIGNED ? 'bg-blue-600/10 text-blue-500 border-blue-500/30' :
                                    'bg-amber-500/10 text-amber-500 border-amber-500/30 animate-pulse'
                                }`}>{inv.status}</span>
                             </td>
                             <td className="p-6 text-right">
                                {inv.status === EInvoiceStatus.DRAFT && (
                                   <button onClick={(e) => { e.stopPropagation(); handleSignInvoice(inv); }} className="px-6 py-2 bg-white text-black rounded-xl text-[9px] font-black uppercase hover:bg-amber-500 transition-all shadow-xl">Ký Số</button>
                                )}
                             </td>
                          </tr>
                        ))}
                     </tbody>
                  </table>
               </div>
            ) : (
               <div className="flex-1 flex flex-col p-10 font-mono">
                  <div className="flex justify-between items-center mb-6">
                     <span className="text-[10px] text-stone-600 uppercase tracking-widest italic">// Cấu trúc bóc tách XML - TCT Standard v2.0</span>
                     <button className="text-[9px] text-amber-500 underline uppercase font-black">Copy Payload</button>
                  </div>
                  <div className="flex-1 bg-black rounded-[2.5rem] border border-white/5 p-8 overflow-y-auto no-scrollbar shadow-inner text-green-500/80 leading-relaxed text-xs">
                     {selectedInvoice?.xmlPayload || "<!-- Chọn một hóa đơn để xem cấu trúc băm Shard XML -->"}
                  </div>
               </div>
            )}
         </div>

         {/* RIGHT: DETAIL & ADVISOR */}
         <div className="xl:col-span-4 flex flex-col gap-8">
            {selectedInvoice ? (
               <div className="ai-panel p-8 bg-white/[0.02] border-amber-500/20 flex flex-col gap-8 shadow-2xl animate-in slide-in-from-right-10">
                  <h3 className="text-xl font-bold text-white uppercase italic tracking-widest flex items-center gap-3">
                     <Receipt size={20} className="text-amber-500" />
                     Bản thảo chi tiết
                  </h3>

                  <div className="space-y-6">
                     <p className="text-[10px] font-black text-amber-500 uppercase tracking-widest">Dòng hàng bóc tách (Vàng & Đá)</p>
                     <div className="space-y-4">
                        {selectedInvoice.items.map((item, idx) => (
                           <div key={idx} className="p-5 bg-black/60 rounded-[2rem] border border-white/5">
                              <p className="text-xs font-bold text-white uppercase mb-2">{item.name}</p>
                              <div className="grid grid-cols-2 gap-4 text-[9px] font-mono text-stone-500">
                                 <div>Vàng: {item.goldWeight} chỉ</div>
                                 <div className="text-right">Đá: {item.stonePrice.toLocaleString()} đ</div>
                                 <div>Công thợ: {item.laborPrice.toLocaleString()} đ</div>
                                 <div className="text-right text-amber-500">Thuế: {item.taxRate}%</div>
                              </div>
                              <div className="mt-3 pt-3 border-t border-white/5 flex justify-between items-end">
                                 <span className="text-[8px] font-black text-stone-600 uppercase">Thành tiền</span>
                                 <span className="text-sm font-black text-white">{item.totalBeforeTax.toLocaleString()} đ</span>
                              </div>
                           </div>
                        ))}
                     </div>
                  </div>

                  <div className="p-6 bg-indigo-500/5 border border-indigo-500/20 rounded-3xl">
                     <div className="flex items-center gap-3 mb-3">
                        <ShieldCheck size={18} className="text-indigo-400" />
                        <h4 className="text-[10px] font-black text-white uppercase tracking-widest">Mã băm chữ ký (RSA-4096)</h4>
                     </div>
                     <p className="text-[9px] text-stone-600 font-mono break-all leading-relaxed">
                        {selectedInvoice.signatureHash || "Awaiting Sealing..."}
                     </p>
                  </div>
               </div>
            ) : (
               <div className="ai-panel p-12 border-dashed border-stone-800 flex flex-col items-center justify-center text-center opacity-30 flex-1">
                  <Database size={64} className="text-stone-700 mb-6" />
                  <p className="text-xl font-serif italic uppercase tracking-widest">Data Shard Awaiting Selection</p>
               </div>
            )}

            <div className="ai-panel p-8 bg-black border-white/5 flex items-center gap-6">
                <p className="text-[11px] text-stone-400 italic leading-relaxed font-light">
                   "Thưa Anh Natt, Can đã bóc tách định mức 'Vàng 18K' và 'Kim cương rời' cho hóa đơn này. Mọi mục **Công thợ** đã được đối soát với Shard nhân sự để đảm bảo tính hợp lệ của chi phí sản xuất."
                </p>
            </div>
         </div>
      </main>
    </div>
  );
};

export default SalesTaxModule;

### src/services/approval/approval-workflow-service.ts ###

import { ApprovalRequest, ApprovalTicket, ApprovalStatus, UserRole } from '@/types';
import { NotifyBus } from '../notificationservice';
import { PersonaID } from '@/types';

export interface ApprovalStats {
  pending: number;
  approvedToday: number;
  rejectedToday: number;
  avgResponseTime: string;
}

export class ApprovalWorkflowService {
  private static instance: ApprovalWorkflowService;
  private tickets: ApprovalTicket[] = []; // In-memory store (Mock DB)

  public static getInstance(): ApprovalWorkflowService {
    if (!ApprovalWorkflowService.instance) {
      ApprovalWorkflowService.instance = new ApprovalWorkflowService();
      // Load mock data
      ApprovalWorkflowService.instance.loadMockData();
    }
    return ApprovalWorkflowService.instance;
  }

  private loadMockData() {
    this.tickets = [
      {
        id: 'TICKET-001',
        request: {
          recordType: 'TRANSACTION',
          changeType: 'UPDATE',
          proposedData: { amount: 150000000, note: 'Điều chỉnh giá vốn lô kim cương' },
          priority: 'HIGH',
          reason: 'Sai lệch tỷ giá nhập khẩu',
          requestedBy: 'USR-ACC-01'
        },
        status: ApprovalStatus.PENDING,
        requestedAt: Date.now() - 3600000,
        workflowStep: 1,
        totalSteps: 2
      },
      {
        id: 'TICKET-002',
        request: {
          recordType: 'DICTIONARY',
          changeType: 'CREATE',
          proposedData: { term: 'SKU_JADE_2026', desc: 'Mã Ngọc Bích Mới' },
          priority: 'LOW',
          reason: 'Thêm mã mới cho BST Mùa Xuân',
          requestedBy: 'USR-PROD-05'
        },
        status: ApprovalStatus.APPROVED,
        requestedAt: Date.now() - 86400000,
        approvedBy: 'ADMIN_NATT',
        approvedAt: Date.now() - 43200000,
        workflowStep: 1,
        totalSteps: 1
      }
    ];
  }

  async submitForApproval(data: ApprovalRequest): Promise<ApprovalTicket> {
    // 1. Kiểm tra Auto-Approve (Logic giả lập)
    if (this.shouldAutoApprove(data)) {
      return this.createTicket(data, ApprovalStatus.APPROVED);
    }
    
    // 2. Tạo ticket Pending
    const ticket = this.createTicket(data, ApprovalStatus.PENDING);
    
    // 3. Gửi thông báo
    NotifyBus.push({
      type: 'RISK', // Dùng loại RISK để gây chú ý cho việc phê duyệt
      title: 'YÊU CẦU PHÊ DUYỆT MỚI',
      content: `Yêu cầu từ ${data.requestedBy}: ${data.changeType} ${data.recordType}. Lý do: ${data.reason}`,
      priority: data.priority === 'CRITICAL' ? 'HIGH' : 'MEDIUM',
      persona: PersonaID.KRIS
    });

    return ticket;
  }

  private createTicket(request: ApprovalRequest, status: ApprovalStatus): ApprovalTicket {
    const ticket: ApprovalTicket = {
      id: `TICKET-${Date.now().toString().slice(-6)}`,
      request,
      status,
      requestedAt: Date.now(),
      workflowStep: 1,
      totalSteps: request.priority === 'CRITICAL' ? 2 : 1 // Critical cần 2 cấp duyệt
    };
    
    if (status === ApprovalStatus.APPROVED) {
        ticket.approvedBy = 'AUTO_SYSTEM';
        ticket.approvedAt = Date.now();
    }

    this.tickets.unshift(ticket);
    return ticket;
  }

  private shouldAutoApprove(data: ApprovalRequest): boolean {
    // Logic: Tự động duyệt nếu độ ưu tiên thấp và thay đổi nhỏ
    if (data.priority === 'LOW' && data.changeType === 'UPDATE') return true;
    return false;
  }

  // --- ACTIONS ---

  async approveTicket(ticketId: string, approverId: string) {
    const ticket = this.tickets.find(t => t.id === ticketId);
    if (!ticket) throw new Error("Ticket not found");

    ticket.status = ApprovalStatus.APPROVED;
    ticket.approvedBy = approverId;
    ticket.approvedAt = Date.now();

    NotifyBus.push({
      type: 'SUCCESS',
      title: 'ĐÃ PHÊ DUYỆT',
      content: `Ticket ${ticketId} đã được duyệt bởi ${approverId}.`,
      persona: PersonaID.THIEN
    });
  }

  async rejectTicket(ticketId: string, approverId: string, reason: string) {
    const ticket = this.tickets.find(t => t.id === ticketId);
    if (!ticket) throw new Error("Ticket not found");

    ticket.status = ApprovalStatus.REJECTED;
    ticket.rejectionReason = reason;
    ticket.approvedBy = approverId; // Người từ chối
    ticket.approvedAt = Date.now();
  }

  // --- GETTERS ---
  
  getStats(): ApprovalStats {
    const now = Date.now();
    const todayStart = new Date().setHours(0,0,0,0);
    
    return {
        pending: this.tickets.filter(t => t.status === ApprovalStatus.PENDING).length,
        approvedToday: this.tickets.filter(t => t.status === ApprovalStatus.APPROVED && (t.approvedAt || 0) > todayStart).length,
        rejectedToday: this.tickets.filter(t => t.status === ApprovalStatus.REJECTED && (t.approvedAt || 0) > todayStart).length,
        avgResponseTime: '1.5 giờ' // Mock static for now
    };
  }

  getTickets(filterStatus: ApprovalStatus | 'ALL' = 'ALL'): ApprovalTicket[] {
      if (filterStatus === 'ALL') return this.tickets;
      return this.tickets.filter(t => t.status === filterStatus);
  }
}

export const ApprovalEngine = ApprovalWorkflowService.getInstance();

### src/services/compliance/certification-service.ts ###

import { Certification, PersonaID } from '@/types';
// TODO: import ShardingService fromts';
import { NotifyBus } from '@/notificationservice';

class CertificationService {
  private static instance: CertificationService;
  private certs: Certification[] = [];
  private sequence: number = 42;
  private renewalReminderDays = 30;

  constructor() {
    this.seedInitialData();
    this.startSimulationCron();
  }

  static getInstance() {
    if (!CertificationService.instance) CertificationService.instance = new CertificationService();
    return CertificationService.instance;
  }

  private seedInitialData() {
    const now = Date.now();
    this.certs = [
      {
        id: 'cert-001',
        certificateNumber: 'CERT-2025-000042',
        title: 'GIA Diamond Report - Natural Diamond',
        description: 'Chứng chỉ giám định kim cương thiên nhiên từ GIA.',
        type: 'QUALITY',
        issuingBody: 'Gemological Institute of America',
        issueDate: now - (90 * 86400000),
        expiryDate: now + (15 * 86400000), // Sắp hết hạn trong 15 ngày
        status: 'VALID',
        verificationStatus: 'VERIFIED',
        createdAt: now - (90 * 86400000),
        updatedAt: now - (90 * 86400000)
      }
    ];
  }

  private startSimulationCron() {
    // Giả lập Cron Job chạy định kỳ để kiểm tra hết hạn (daily 8 AM)
    setInterval(() => {
      this.checkExpiringCertifications();
    }, 60000); // Check mỗi phút cho demo
  }

  private async checkExpiringCertifications() {
    const now = Date.now();
    let hasChanges = false;

    this.certs = this.certs.map(cert => {
      // Fix: Use type assertion as string to resolve "unintentional comparison" error caused by incomplete union inference
      if ((cert.status as string) === 'ARCHIVED' || (cert.status as string) === 'EXPIRED') return cert;

      const daysToExpiry = cert.expiryDate 
        ? Math.ceil((cert.expiryDate - now) / 86400000) 
        : Infinity;

      // Logic Cảnh báo
      if (daysToExpiry <= this.renewalReminderDays && daysToExpiry > 0) {
        NotifyBus.push({
          type: 'RISK',
          title: 'CHỨNG CHỈ SẮP HẾT HẠN',
          content: `Chứng chỉ ${cert.certificateNumber} (${cert.title}) còn ${daysToExpiry} ngày. Vui lòng làm mới.`,
          persona: PersonaID.KRIS,
          priority: 'HIGH'
        });
      }

      // Logic Quá hạn
      if (cert.expiryDate && cert.expiryDate < now && cert.status !== 'EXPIRED') {
        hasChanges = true;
        NotifyBus.push({
          type: 'RISK',
          title: 'CHỨNG CHỈ ĐÃ HẾT HẠN',
          content: `Chứng chỉ ${cert.certificateNumber} đã quá hạn vào ngày ${new Date(cert.expiryDate).toLocaleDateString()}.`,
          persona: PersonaID.KRIS,
          priority: 'HIGH'
        });
        return { ...cert, status: 'EXPIRED', updatedAt: now };
      }

      return cert;
    });
  }

  async getCerts() { return [...this.certs]; }

  async createCertification(data: Omit<Certification, 'id' | 'certificateNumber' | 'createdAt' | 'updatedAt'>) {
    const now = Date.now();
    // FIX: Syntax Error Safe Increment
    this.sequence += 1;
    const certNumber = `CERT-${new Date().getFullYear()}-${this.sequence.toString().padStart(6, '0')}`;
    
    const newCert: Certification = {
      ...data,
      id: `CERT-${now}`,
      certificateNumber: certNumber,
      createdAt: now,
      updatedAt: now,
      status: data.status || 'PENDING'
    };

    this.certs.unshift(newCert);
    return newCert;
  }

  async renewCertification(certId: string, renewalData: { issueDate: number; expiryDate: number }) {
    const now = Date.now();
    const oldCert = this.certs.find(c => c.id === certId);
    if (!oldCert) throw new Error("Certification not found");

    // 1. Tạo bản gia hạn mới
    const renewed = await this.createCertification({
      ...oldCert,
      issueDate: renewalData.issueDate,
      expiryDate: renewalData.expiryDate,
      status: 'PENDING',
      verificationStatus: 'PENDING',
      renewalOf: oldCert.id
    });

    // 2. Lưu trữ bản cũ
    this.certs = this.certs.map(c => 
      c.id === certId ? { ...c, status: 'ARCHIVED', replacedBy: renewed.id, updatedAt: now } : c
    );

    return renewed;
  }

  async getStatistics() {
    return {
      total: this.certs.length,
      active: this.certs.filter(c => c.status === 'VALID').length,
      expiringSoon: this.certs.filter(c => {
          if (!c.expiryDate || c.status !== 'VALID') return false;
          const diff = c.expiryDate - Date.now();
          return diff > 0 && diff < 30 * 86400000;
      }).length,
      expired: this.certs.filter(c => c.status === 'EXPIRED').length,
      pendingVerification: this.certs.filter(c => c.verificationStatus === 'PENDING').length,
      activePercent: (this.certs.filter(c => c.status === 'VALID').length / (this.certs.length || 1)) * 100
    };
  }
}

export const CertificationProvider = CertificationService.getInstance();

### src/services/dashboard-service.ts ###

import { HUDMetric, Department, ActionLog } from '@/types';
import { getCell } from '@/cells/shared-kernel/smartlink.registry';

/**
 * 📊 DASHBOARD SERVICE - REGISTRY-BASED
 * Thực thi bóc tách dữ liệu qua SmartLink Registry v5.0.
 * Tuân thủ tuyệt đối Boundary Law (Book III Điều 7).
 */
class DashboardService {
  private static instance: DashboardService;

  static getInstance() {
    if (!DashboardService.instance) DashboardService.instance = new DashboardService();
    return DashboardService.instance;
  }

  async getHUDMetrics(): Promise<HUDMetric[]> {
    // 🛡️ HỢP HIẾN: Pull logic thực thi từ Registry thay vì import tĩnh
    const WarehouseProvider = await getCell('WAREHOUSE');
    const SalesProvider = await getCell('SALES');

    // Bóc tách dữ liệu thống kê từ các Shard Isolate
    const inventory = WarehouseProvider.getAllInventory();
    const totalItems = inventory.length;
    
    const totalRevenue = await SalesProvider.getRevenueStats();

    return [
      {
        id: 'M1',
        name: 'DOANH THU CHỐT SHARD',
        value: totalRevenue || 449120,
        unit: 'VND',
        trend: 'UP',
        department: Department.SALES,
        icon: '💰'
      },
      {
        id: 'M2',
        name: 'TỒN KHO VÀNG',
        value: totalItems,
        unit: 'SP',
        trend: 'STABLE',
        department: Department.PRODUCTION,
        icon: '📦'
      }
    ];
  }

  async getActionLogs(): Promise<ActionLog[]> {
    return [];
  }
}

export const DashboardProvider = DashboardService.getInstance();

### src/services/quantum-engine.ts ###

import { 
  QuantumState, QuantumEvent, ConsciousnessField, 
  EntanglementPair, NeuralPulse, PersonaID 
} from '@/types';
import { ShardingService } from './blockchainservice';
import { NotifyBus } from './notificationservice';

// --- CONSTANTS ---
const COHERENCE_DECAY = 0.05; // Mất tính kết hợp theo thời gian
const MAX_ENTROPY = 100;

/**
 * QUANTUM FLOW ORCHESTRATOR (QFO)
 * Hệ thần kinh xử lý phi tuyến tính, mô phỏng hành vi lượng tử
 * để đưa ra quyết định tối ưu trong môi trường hỗn loạn.
 */
export class QuantumFlowEngine {
  private static instance: QuantumFlowEngine;
  
  // Trạng thái hệ thống (System State)
  private state: QuantumState = {
    coherence: 1.0,
    entropy: 10,
    superpositionCount: 0,
    entanglementCount: 0,
    energyLevel: 0.8,
    waveFunction: { amplitude: 0.7, phase: 0, frequency: 440 }
  };

  // Trường Ý Thức (Consciousness Field)
  private consciousness: ConsciousnessField = {
    awarenessLevel: 0.5,
    focusPoints: [],
    mood: 'STABLE',
    lastCollapse: Date.now()
  };

  private entanglements: EntanglementPair[] = [];
  private events: QuantumEvent[] = [];
  private listeners: ((state: QuantumState, consciousness: ConsciousnessField) => void)[] = [];

  // Giả lập Neural Network đơn giản
  private neurons = new Map<string, number>(); // ID -> Activation Level

  private constructor() {
    this.startHeartbeat();
  }

  public static getInstance() {
    if (!QuantumFlowEngine.instance) QuantumFlowEngine.instance = new QuantumFlowEngine();
    return QuantumFlowEngine.instance;
  }

  /**
   * Vòng lặp sự sống (Game Loop của hệ thống)
   */
  private startHeartbeat() {
    setInterval(() => {
      // 1. Decoherence (Mất dần tính kết hợp)
      if (this.state.coherence > 0.2) {
        this.state.coherence -= COHERENCE_DECAY * Math.random();
      }

      // 2. Wave Function Oscillation (Dao động sóng)
      this.state.waveFunction.phase += 0.1;
      this.state.waveFunction.amplitude = 0.5 + Math.sin(Date.now() / 1000) * 0.2;

      // 3. Update Consciousness based on Entropy
      if (this.state.entropy > 80) this.consciousness.mood = 'CRITICAL';
      else if (this.state.entropy > 50) this.consciousness.mood = 'CAUTIOUS';
      else this.consciousness.mood = 'STABLE';

      this.notifyListeners();
    }, 1000);
  }

  // --- SENSITIVITY ANALYZER ---

  /**
   * Phân tích sự kiện đầu vào và tính toán Vector Độ Nhạy
   */
  public analyzeSensitivity(eventType: string, data: any): QuantumEvent {
    // Heuristic Logic: Định nghĩa độ nhạy dựa trên quy tắc nghiệp vụ
    let temporal = 0.2;
    let financial = 0.1;
    let risk = 0.1;
    let operational = 0.3;

    if (eventType.includes('ORDER')) {
        financial = 0.9;
        temporal = 0.7; // Khách hàng chờ
    }
    if (eventType.includes('RISK') || eventType.includes('ALERT')) {
        risk = 0.95;
        temporal = 1.0; // Xử lý ngay
    }
    if (eventType.includes('PRODUCTION')) {
        operational = 0.8;
    }

    // Nếu giá trị đơn hàng lớn -> Tăng Financial & Risk
    if (data.amount && data.amount > 1000000000) { // > 1 Tỷ
        financial = 1.0;
        risk += 0.3;
    }

    const probability = (temporal + financial + risk + operational) / 4;

    return {
      id: `Q-EVT-${Date.now()}`,
      type: eventType,
      sensitivityVector: { temporal, financial, risk, operational },
      status: 'SUPERPOSITION',
      probability,
      timestamp: Date.now()
    };
  }

  // --- CORE PROCESSING ---

  /**
   * Tiếp nhận sự kiện từ thế giới bên ngoài (EventBridge)
   */
  public processEvent(eventType: string, data: any) {
    // 1. Analyze
    const qEvent = this.analyzeSensitivity(eventType, data);
    this.events.push(qEvent);
    this.state.superpositionCount += 1;

    // 2. Update System Energy
    this.state.energyLevel = Math.min(1.0, this.state.energyLevel + 0.05);
    this.state.entropy += (qEvent.sensitivityVector.risk * 5);

    // 3. Entanglement Logic (Tạo mối liên kết)
    if (eventType === 'SALES_ORDER_CREATED') {
       this.createEntanglement('SALES', 'INVENTORY', 0.8);
       this.createEntanglement('SALES', 'ACCOUNTING', 0.9);
    }

    // 4. Wave Function Collapse Check (Quyết định sụp đổ hay giữ chồng chập)
    if (qEvent.probability > 0.8 || qEvent.sensitivityVector.risk > 0.8) {
        this.collapseWaveFunction(qEvent);
    } else {
        console.log(`[QUANTUM] Sự kiện ${eventType} được giữ ở trạng thái chồng chập (Chưa quyết định).`);
    }

    this.notifyListeners();
  }

  /**
   * Sụp đổ hàm sóng: Đưa ra quyết định cụ thể
   */
  private collapseWaveFunction(event: QuantumEvent) {
    event.status = 'COLLAPSED';
    this.state.superpositionCount -= 1;
    this.state.coherence = 1.0; // Reset coherence khi có quyết định
    this.consciousness.lastCollapse = Date.now();
    this.consciousness.focusPoints.push(event.type);
    
    // Giảm Entropy sau khi xử lý
    this.state.entropy = Math.max(0, this.state.entropy - 10);

    // Decision Logic
    if (event.sensitivityVector.risk > 0.8) {
        event.decision = 'KÍCH HOẠT GIAO THỨC BẢO MẬT CAO (OMEGA LOCK)';
        NotifyBus.push({
            type: 'RISK',
            title: 'Sụp Đổ Hàm Sóng: RỦI RO CAO',
            content: `Hệ thống đã tự động kích hoạt cơ chế phòng vệ do phát hiện sự kiện ${event.type} có độ nhạy rủi ro ${(event.sensitivityVector.risk * 100).toFixed(0)}%.`,
            persona: PersonaID.KRIS
        });
    } else if (event.sensitivityVector.financial > 0.8) {
        event.decision = 'ƯU TIÊN XỬ LÝ (FAST TRACK)';
        NotifyBus.push({
            type: 'SUCCESS',
            title: 'Sụp Đổ Hàm Sóng: Ưu Tiên',
            content: `Đơn hàng giá trị cao đã được đưa vào luồng Fast Track.`,
            persona: PersonaID.CAN
        });
    }

    console.log(`[QUANTUM] Collapsed Event: ${event.type} -> Decision: ${event.decision}`);
  }

  private createEntanglement(entityA: string, entityB: string, strength: number) {
      const id = `ENT-${Date.now()}`;
      this.entanglements.push({
          id, entityA, entityB, strength, type: strength > 0.8 ? 'GHZ_STATE' : 'BELL_PAIR'
      });
      this.state.entanglementCount += 1;
  }

  // --- PUBLIC API FOR UI ---

  public subscribe(listener: (state: QuantumState, consciousness: ConsciousnessField) => void) {
    this.listeners.push(listener);
    return () => { this.listeners = this.listeners.filter(l => l !== listener); };
  }

  private notifyListeners() {
    this.listeners.forEach(l => l({ ...this.state }, { ...this.consciousness }));
  }

  public getEvents() { return this.events; }
  public getEntanglements() { return this.entanglements; }
  
  public manualCollapse() {
      // Cho phép người dùng can thiệp thủ công (Observation Effect)
      this.state.coherence = 1.0;
      this.state.entropy = 0;
      this.events.forEach(e => {
          if (e.status === 'SUPERPOSITION') this.collapseWaveFunction(e);
      });
      this.notifyListeners();
  }
}

export const QuantumBrain = QuantumFlowEngine.getInstance();

### src/services/sales-core.ts ###

import { 
  UserPosition,
  PositionType,
  SalesChannel,
  WarehouseLocation,
  ProductType,
  OrderStatus,
  Customer,
  LogisticsInfo,
  PaymentInfo,
  SalesPerson,
  CommissionInfo,
  OrderItem,
  OrderPricing,
  SalesOrder
} from '@/types';
import { SellerEngine } from './sellerengine';

// ============================================================================
// 🧠 SALES CORE ENGINE (LOGIC LAYER)
// ============================================================================

export class SalesCoreEngine {
  private static instance: SalesCoreEngine;

  static getInstance(): SalesCoreEngine {
    if (!SalesCoreEngine.instance) {
      SalesCoreEngine.instance = new SalesCoreEngine();
    }
    return SalesCoreEngine.instance;
  }

  /**
   * Tính toán Pricing & P&L cho đơn hàng
   */
  public calculatePricing(
    items: OrderItem[], 
    discountPercent: number = 0, 
    shippingFee: number = 0,
    customerTier: string = 'STANDARD'
  ): OrderPricing {
    let subtotal = 0;
    let basePriceTotal = 0;
    let costOfGoods = 0;
    let taxAmount = 0;

    items.forEach(item => {
      const itemTotal = item.unitPrice * item.quantity;
      basePriceTotal += itemTotal;
      subtotal += itemTotal - item.discount;
      costOfGoods += item.costPrice * item.quantity;
      
      // Thuế tính trên giá sau giảm
      const taxableAmount = itemTotal - item.discount;
      taxAmount += taxableAmount * (item.taxRate / 100);
    });

    // Tier based discount adjustment
    let tierDiscount = 0;
    if (customerTier === 'VIP_DIAMOND') tierDiscount = 0.05; // Extra 5%
    if (customerTier === 'VIP_GOLD') tierDiscount = 0.02;    // Extra 2%

    const totalDiscount = (subtotal * (discountPercent + tierDiscount) / 100);
    
    // GĐB Value: Giá trị đảm bảo thường là giá thực tế khách trả (trừ ship/thuế/bảo hiểm)
    const gdbPriceTotal = subtotal - totalDiscount;

    // Exchange Rate Logic (Mặc định)
    const exchangeRate = 0.85; 

    const insuranceFee = gdbPriceTotal > 50000000 ? gdbPriceTotal * 0.005 : 0; // 0.5% nếu > 50tr

    const totalAmount = gdbPriceTotal + taxAmount + shippingFee + insuranceFee;
    const grossProfit = (totalAmount - taxAmount - shippingFee - insuranceFee) - costOfGoods;
    const profitMargin = totalAmount > 0 ? (grossProfit / totalAmount) * 100 : 0;

    return {
      subtotal,
      basePriceTotal,
      gdbPriceTotal,
      exchangeRate,
      discountPercentage: discountPercent + (tierDiscount * 100),
      promotionDiscount: totalDiscount,
      taxAmount,
      shippingFee,
      insuranceFee,
      totalAmount,
      costOfGoods,
      grossProfit,
      profitMargin
    };
  }

  /**
   * Tính toán hoa hồng dựa trên Pricing & SalesPerson KPI
   */
  public calculateCommission(
    salesPerson: SalesPerson, 
    pricing: OrderPricing, 
    items: OrderItem[]
  ): CommissionInfo {
    let commissionableRevenue = pricing.gdbPriceTotal;
    
    // Base Rate theo vị trí
    let baseRate = 2; // 2% mặc định
    if (salesPerson.position.role === PositionType.COLLABORATOR) baseRate = 10; // CTV cao hơn vì không lương cứng

    // KPI Multiplier
    const kpiFactor = 1 + ((salesPerson.kpiScore - 100) / 100); // 120 điểm -> 1.2x

    const estimatedAmount = commissionableRevenue * (baseRate / 100) * kpiFactor;

    return {
      policyId: 'POL-2026-STD',
      baseRate,
      kpiFactor,
      estimatedAmount,
      finalAmount: estimatedAmount,
      status: 'PENDING',
      total: estimatedAmount,
      shell: pricing.subtotal * 0.05, // Mock allocation
      stone: pricing.subtotal * 0.03  // Mock allocation
    };
  }

  /**
   * Factory Method: Khởi tạo Đơn hàng chuẩn hóa
   */
  public createSalesOrder(
    channel: SalesChannel,
    customer: Customer,
    salesPerson: SalesPerson,
    items: OrderItem[],
    WAREHOUSE: WarehouseLocation = WarehouseLocation.HCM_HEADQUARTER
  ): SalesOrder {
    const pricing = this.calculatePricing(items, 0, 0, customer.tier);
    const commission = this.calculateCommission(salesPerson, pricing, items);

    return {
      orderId: `SO-${Date.now()}`,
      orderType: channel,
      customer,
      items,
      pricing,
      payment: {
        method: 'CASH',
        status: 'UNPAID',
        depositAmount: 0,
        remainingAmount: pricing.totalAmount,
        currency: 'VND'
      },
      // Fixed: OrderStatus.DRAFT is now part of the consolidated enum member list
      status: OrderStatus.DRAFT,
      WAREHOUSE,
      salesPerson,
      commission,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
  }
}

export const SalesCore = SalesCoreEngine.getInstance();

### src/services/sales-service.ts ###

/**
 * ⚠️ LEGACY REDIRECT WRAPPER (PHASE 1.5)
 * DO NOT IMPLEMENT BUSINESS LOGIC HERE.
 * All Sales logic lives in: src/cells/sales-cell/sales.service.ts
 */
export { SalesProvider } from '@/cells/sales-cell/sales.service';

### src/services/tax-report-service.ts ###

import { BankTransaction, VATReport, PITReport, EmployeePayroll, VATEntry, TaxCalculationResult } from '@/types';

export class TaxReportService {
  /**
   * Tính toán Thuế TNDN (CIT) với ưu đãi
   */
  static calculateCorporateTax(revenue: number, expense: number, incentiveRate: number = 0): TaxCalculationResult['cit'] {
    const taxableIncome = Math.max(0, revenue - expense);
    const standardRate = 0.20; // 20%
    
    const taxAmount = taxableIncome * standardRate;
    const incentiveAmount = taxAmount * incentiveRate;
    
    return {
      taxableIncome,
      rate: standardRate * 100,
      incentives: { default: incentiveAmount },
      amount: taxAmount - incentiveAmount
    };
  }

  static generateVATReport(transactions: BankTransaction[], period: string): VATReport {
    const entries: VATEntry[] = [
      {
        category: 'Vàng trang sức 18K (AU750)',
        salesValue: 2500000000,
        purchaseValue: 2100000000,
        addedValue: 400000000,
        taxRate: 10,
        taxAmount: 40000000
      },
      {
        category: 'Kim cương GIA & Đá quý',
        salesValue: 1800000000,
        purchaseValue: 1550000000,
        addedValue: 250000000,
        taxRate: 10,
        taxAmount: 25000000
      },
      {
        category: 'Sản phẩm chế tác theo đơn',
        salesValue: 950000000,
        purchaseValue: 780000000,
        addedValue: 170000000,
        taxRate: 10,
        taxAmount: 17000000
      }
    ];

    const totalAddedValue = entries.reduce((sum, e) => sum + e.addedValue, 0);
    const totalVATPayable = entries.reduce((sum, e) => sum + e.taxAmount, 0);

    return {
      period,
      entries,
      totalAddedValue,
      totalVATPayable,
      accountingStandard: 'TT200',
      formNumber: '03/GTGT'
    };
  }

  static generatePITReport(payrolls: EmployeePayroll[], period: string): PITReport {
    const entries = payrolls.map(p => ({
      employeeName: p.name,
      employeeCode: p.employeeCode || 'N/A',
      taxableIncome: p.taxableIncome || 0,
      deductions: (p.baseSalary + p.allowanceLunch) - (p.taxableIncome || 0),
      taxPaid: p.personalTax || 0
    }));

    return {
      period,
      entries,
      totalTaxableIncome: entries.reduce((sum, e) => sum + e.taxableIncome, 0),
      totalTaxPaid: entries.reduce((sum, e) => sum + e.taxPaid, 0)
    };
  }
}

### src/core/core/dictionary/services/dictionary-service.ts ###
import { DictionaryVersion } from '@/types';

class DictionaryService {
  private static instance: DictionaryService;
  private versions: DictionaryVersion[] = [];
  private isFrozen: boolean = false;

  static getInstance() {
    if (!DictionaryService.instance) DictionaryService.instance = new DictionaryService();
    return DictionaryService.instance;
  }

  async createSnapshot(type: string, comment: string): Promise<DictionaryVersion> {
    const newVersion: DictionaryVersion = {
      id: `VER-${Date.now()}`,
      type,
      version: String(this.versions.length + 1),
      // Fixed: added required properties versionNumber and status
      versionNumber: this.versions.length + 1,
      status: 'ACTIVE',
      isFrozen: false,
      createdAt: Date.now(),
      termsCount: Math.floor(Math.random() * 1000) + 500, // Mock
      comment
    };
    this.versions.unshift(newVersion);
    return newVersion;
  }

  async freezeVersion(id: string) {
    const ver = this.versions.find(v => v.id === id);
    if (ver) ver.isFrozen = true;
  }

  getVersions() {
    return [...this.versions];
  }

  async rollbackTo(id: string): Promise<DictionaryVersion> {
    const target = this.versions.find(v => v.id === id);
    if (!target) throw new Error("Version not found");
    
    // Tạo version mới từ target
    return this.createSnapshot(target.type, `Rollback from v${target.version}`);
  }
}

export const DictService = DictionaryService.getInstance();
### src/services/dictionary-service.ts ###

import { DictionaryVersion } from '@/types';

export class DictionaryService {
  private static instance: DictionaryService;
  private versions: DictionaryVersion[] = [];

  private constructor() {
    this.seedMockData();
  }

  static getInstance() {
    if (!DictionaryService.instance) {
      DictionaryService.instance = new DictionaryService();
    }
    return DictionaryService.instance;
  }

  private seedMockData() {
    // Version 1 (Initial)
    this.versions.push({
      id: 'VER-001',
      version: "1.0.0", // string
      versionNumber: 1,
      status: 'ARCHIVED',
      isFrozen: true,
      termsCount: 10,
      dictionaryId: 'ADMIN_DICT',
      data: { SKUList: ['NNA-01'], ValidSuppliers: ['Tâm Luxury'] },
      changes: { added: 10, removed: 0, modified: 0, diffSummary: ['Initial load'] },
      createdBy: 'SYSTEM_INIT',
      createdAt: Date.now() - 10000000,
      metadata: { reason: 'System Initialization' },
      type: 'CORE' 
    });

    // Version 2 (Current)
    this.versions.push({
      id: 'VER-002',
      version: "2.0.0", // string
      versionNumber: 2,
      status: 'ACTIVE',
      isFrozen: false,
      termsCount: 12,
      dictionaryId: 'ADMIN_DICT',
      previousVersionId: 'VER-001',
      data: { SKUList: ['NNA-01', 'NNU-02'], ValidSuppliers: ['Tâm Luxury', 'Gia Công A'] },
      changes: { added: 2, removed: 0, modified: 1, diffSummary: ['Added SKU NNU-02', 'Added Supplier'] },
      createdBy: 'ADMIN_NATT',
      createdAt: Date.now() - 5000000,
      metadata: { reason: 'Update Q1/2026' },
      type: 'UPDATE' 
    });
  }

  getVersions(): DictionaryVersion[] {
    return [...this.versions].sort((a, b) => (b.versionNumber || 0) - (a.versionNumber || 0));
  }

  getCurrentVersion(): DictionaryVersion {
    return this.getVersions()[0];
  }

  async rollbackTo(versionId: string): Promise<DictionaryVersion> {
    await new Promise(r => setTimeout(r, 1500)); // Simulate DB latency
    
    const target = this.versions.find(v => v.id === versionId);
    if (!target) throw new Error("Version not found");

    const newVersion: DictionaryVersion = {
      id: `VER-ROLLBACK-${Date.now()}`,
      version: String((this.getCurrentVersion().versionNumber || 0) + 1),
      versionNumber: (this.getCurrentVersion().versionNumber || 0) + 1,
      status: 'ACTIVE',
      isFrozen: false,
      termsCount: target.termsCount,
      dictionaryId: target.dictionaryId,
      previousVersionId: this.getCurrentVersion().id,
      data: target.data,
      changes: { 
        added: 0, removed: 0, modified: 0, 
        diffSummary: [`Rollback to v${target.versionNumber}`] 
      },
      createdBy: 'ADMIN_NATT',
      createdAt: Date.now(),
      metadata: { reason: `Emergency Rollback to v${target.versionNumber}` },
      type: 'ROLLBACK' 
    };

    this.versions.push(newVersion);
    return newVersion;
  }
}

export const DictService = DictionaryService.getInstance();

export default DictionaryService;

--- 7. CELL MANIFEST LIST ---
### src/cells/business/buyback-cell/cell.manifest.json ###
{
  "cell_id": "buyback-cell", "version": "2.0.0", "wave": "3", "layer": "business",
  "status": "ACTIVE",
  "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" },
  "adn": {
    "identity": { "name": "Buyback Cell", "domain": "Thu mua lại trang sức Tâm Luxury" },
    "capability": { "primary": ["assessItem","makeOffer","acceptOffer","completeTransaction"], "secondary": ["authentication","depreciationCalc"] },
    "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" }
  }
}
### src/cells/business/sales-cell/cell.manifest.json ###
{ "cell_id": "sales-cell", "version": "2.0.0", "wave": "3", "layer": "business", "status": "ACTIVE", "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" }, "adn": { "identity": { "name": "Sales Cell", "domain": "Bán hàng trang sức Tâm Luxury" }, "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" } } }
### src/cells/business/pricing-cell/cell.manifest.json ###
{
  "cell_id": "pricing-cell",
  "version": "2.0.0",
  "wave": "3",
  "layer": "business",
  "status": "ACTIVE",
  "adn": {
    "identity": {
      "name": "Pricing Cell",
      "domain": "Pricing & Cost Calculation",
      "description": "Tâm Luxury jewelry pricing engine — gold prices, labor costs, markup tiers, full product pricing"
    },
    "capability": {
      "primary": ["calculateProductPrice", "updateGoldMarketPrice", "determineLaborCost"],
      "secondary": ["priceHistory", "markupManagement", "customQuoteDetection"]
    },
    "boundary": {
      "owns": ["gold_prices", "markup_tiers", "labor_formulas", "product_pricing"],
      "forbidden_imports": ["sales-cell", "order-cell", "customer-cell", "showroom-cell", "promotion-cell", "buyback-cell", "warranty-cell", "inventory-cell"],
      "communicates_via": "shared-contracts-cell + EDA events"
    },
    "trace": {
      "events_emitted": [
        "pricing.gold.market.updated",
        "pricing.product.calculated",
        "pricing.markup.changed",
        "pricing.custom_quote.required"
      ],
      "events_consumed": [
        "external.gold.price.updated",
        "inventory.material.received"
      ]
    },
    "confidence": {
      "labor_formulas": "VERIFIED — extracted from Bảng Giá 2025 Excel (4049-char formula)",
      "gold_prices": "BASELINE — needs daily market update",
      "markup_tiers": "VERIFIED — 3 tiers (15%, 20%, 30%) from SaleTerminal v2 review"
    },
    "smartlink": {
      "depends_on": [],
      "depended_by": ["sales-cell", "order-cell", "buyback-cell", "warranty-cell", "promotion-cell"]
    },
    "lifecycle": {
      "created_at": "2026-02-10",
      "scaffolded_at": "2026-02-10",
      "implemented_at": "2026-02-11",
      "implemented_by": "Băng (Data Steward & Architect)",
      "approved_by": "Anh Natt (Gatekeeper)"
    }
  },
  "structure": {
    "current_structure": "5_LAYER",
    "target_structure": "5_LAYER",
    "layers": ["domain", "application", "interface", "infrastructure", "ports"],
    "migration_status": "COMPLETE — upgraded from FLAT scaffold"
  }
}
### src/cells/business/promotion-cell/cell.manifest.json ###
{ "cell_id": "promotion-cell", "version": "2.0.0", "wave": "3", "layer": "business", "status": "ACTIVE", "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" }, "adn": { "identity": { "name": "Promotion Cell", "domain": "Khuyến mãi Tâm Luxury" }, "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" } } }
### src/cells/business/customer-cell/cell.manifest.json ###
{ "cell_id": "customer-cell", "version": "2.0.0", "wave": "3", "layer": "business", "status": "ACTIVE", "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" }, "adn": { "identity": { "name": "Customer Cell", "domain": "Quản lý khách hàng Tâm Luxury" }, "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" } } }
### src/cells/business/inventory-cell/cell.manifest.json ###
{
  "cell_id": "inventory-cell",
  "version": "2.0.0",
  "wave": "3",
  "layer": "business",
  "status": "ACTIVE",
  "adn": {
    "identity": {
      "name": "Inventory Cell",
      "domain": "Inventory & Stock Management",
      "description": "Tâm Luxury jewelry inventory — stock tracking, reservations, branch management, serial number tracking"
    },
    "capability": {
      "primary": ["checkAvailability", "reserveItem", "deductItem", "releaseReservation"],
      "secondary": ["stockAlerts", "crossBranchTransfer", "expiredReservationCleanup", "systemOverview"]
    },
    "boundary": {
      "owns": ["inventory_items", "stock_levels", "reservations", "location_assignments"],
      "forbidden_imports": ["sales-cell", "order-cell", "customer-cell", "showroom-cell", "promotion-cell", "buyback-cell", "warranty-cell", "pricing-cell"],
      "communicates_via": "shared-contracts-cell + EDA events"
    },
    "trace": {
      "events_emitted": [
        "inventory.item.received",
        "inventory.item.reserved",
        "inventory.reservation.released",
        "inventory.item.sold",
        "inventory.item.transferred",
        "inventory.cross_branch.transfer_requested",
        "inventory.item.maintenance",
        "inventory.stock.alert",
        "inventory.reservation.expired"
      ],
      "events_consumed": [
        "pricing.product.calculated",
        "order.confirmed",
        "buyback.item.received",
        "warranty.repair.requested"
      ]
    },
    "confidence": {
      "item_statuses": "VERIFIED — 7 states with validated transition matrix",
      "locations": "VERIFIED — 7 locations across HN/HCM branches",
      "reservation_rules": "VERIFIED — 3 tiers (STANDARD/VIP/VVIP) with deposit logic",
      "stock_alerts": "VERIFIED — 4 alert types with configurable thresholds"
    },
    "smartlink": {
      "depends_on": ["pricing-cell"],
      "depended_by": ["sales-cell", "order-cell", "buyback-cell", "warranty-cell", "showroom-cell"]
    },
    "lifecycle": {
      "created_at": "2026-02-11",
      "scaffolded_at": "2026-02-11",
      "implemented_at": "2026-02-12",
      "implemented_by": "Thiên (Chief Architect)",
      "port_base_by": "Bối Bối (Toolsmith)",
      "approved_by": "Anh Natt (Gatekeeper)"
    }
  },
  "structure": {
    "current_structure": "5_LAYER",
    "target_structure": "5_LAYER",
    "layers": ["domain", "application", "interface", "infrastructure", "ports"],
    "migration_status": "COMPLETE — upgraded from FLAT scaffold"
  }
}
### src/cells/business/warranty-cell/cell.manifest.json ###
{
  "cell_id": "warranty-cell", "version": "2.0.0", "wave": "3", "layer": "business",
  "status": "ACTIVE",
  "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" },
  "adn": {
    "identity": { "name": "Warranty Cell", "domain": "Bảo hành trang sức Tâm Luxury" },
    "capability": {
      "primary": ["checkWarrantyStatus", "submitClaim", "approveClaim", "rejectClaim"],
      "secondary": ["trackRepair", "overdueClaims", "freePolishTracking"]
    },
    "trace": {
      "events_emitted": ["warranty.claim.submitted","warranty.claim.approved","warranty.claim.rejected","warranty.repair.started","warranty.repair.completed","warranty.item.returned"],
      "events_consumed": ["order.completed","inventory.item.maintenance"]
    },
    "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" }
  }
}
### src/cells/business/order-cell/cell.manifest.json ###
{ "cell_id": "order-cell", "version": "2.0.0", "wave": "3", "layer": "business", "status": "ACTIVE", "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" }, "adn": { "identity": { "name": "Order Cell", "domain": "Quản lý đơn hàng Tâm Luxury" }, "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" } } }
### src/cells/business/showroom-cell/cell.manifest.json ###
{ "cell_id": "showroom-cell", "version": "2.0.0", "wave": "3", "layer": "business", "status": "ACTIVE", "structure": { "current_structure": "5_LAYER", "migration_status": "COMPLETE" }, "adn": { "identity": { "name": "Showroom Cell", "domain": "Trưng bày & hẹn khách Tâm Luxury" }, "lifecycle": { "implemented_by": "Băng", "approved_by": "Anh Natt (Gatekeeper)" } } }
### src/cells/infrastructure/warehouse-cell/cell.manifest.json ###
{
  "cell": {
    "name": "warehouse-cell",
    "version": "0.1.0",
    "wave": "WAVE_2",
    "type": "infrastructure",
    "status": "QUARANTINED"
  },
  "quarantine": {
    "reason": "Scaffold with basic structure — awaiting full domain logic implementation",
    "restrictions": ["no-import", "no-deployment", "development-only"],
    "exit_criteria": "Domain logic implemented + tests passing + Kim/Băng review",
    "assigned_to": "Kim + Băng"
  },
  "adn": {
    "identity": {
      "id": "warehouse-cell",
      "description": "Warehouse management — raw materials, semi-finished, finished products",
      "owner": "NATT-OS-TEAM"
    },
    "capability": {
      "exports": ["WarehouseCell", "WarehouseItem", "IWarehouseRepository"],
      "imports": [],
      "events_emitted": ["warehouse.goods.received", "warehouse.goods.released", "warehouse.inventory.updated"],
      "events_consumed": ["order.created", "production.completed"]
    },
    "boundary": {
      "allowed_dependencies": ["config-cell", "audit-cell"],
      "forbidden_imports": ["**/kernel/**", "**/business/**"],
      "isolation_level": "STRICT"
    },
    "trace": {
      "audit_required": true,
      "log_level": "INFO",
      "event_sourcing": true
    },
    "confidence": {
      "test_coverage_minimum": 0,
      "constitutional_compliance": true,
      "last_audit": null
    },
    "smartlink": {
      "linked_cells": ["sync-cell", "smartlink-cell"],
      "event_bus_channels": ["warehouse.*"]
    },
    "lifecycle": {
      "created_phase": "WAVE_2_CLEANUP",
      "current_state": "QUARANTINED",
      "transitions": [
        { "from": "MISPLACED", "to": "QUARANTINED", "reason": "Moved to infrastructure/ + scaffold created" }
      ]
    }
  },
  "layers": {
    "domain": true,
    "application": true,
    "interface": true,
    "infrastructure": true,
    "ports": true
  }
}
### src/cells/infrastructure/smartlink-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "smartlink-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "active"
  },
  "cell": "smartlink-cell",
  "status": "ACTIVE",
  "layer": "infrastructure",
  "wave": 2
}
### src/cells/infrastructure/sync-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "sync-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "active"
  },
  "cell": "sync-cell",
  "status": "ACTIVE",
  "layer": "infrastructure",
  "wave": 2
}
### src/cells/kernel/audit-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "audit-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "ENFORCED"
  },
  "cell": "audit-cell",
  "status": "ACTIVE",
  "layer": "foundation_governance",
  "wave": 0,
  "governance_level": "IMMUTABLE_EXCEPT_GATEKEEPER"
}
### src/cells/kernel/monitor-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "monitor-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "ENFORCED"
  },
  "cell": "monitor-cell",
  "status": "ACTIVE",
  "layer": "foundation_governance",
  "wave": 0,
  "governance_level": "IMMUTABLE_EXCEPT_GATEKEEPER"
}
### src/cells/kernel/config-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "config-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "ENFORCED"
  },
  "cell": "config-cell",
  "status": "ACTIVE",
  "layer": "foundation_governance",
  "wave": 0,
  "governance_level": "IMMUTABLE_EXCEPT_GATEKEEPER"
}
### src/cells/kernel/rbac-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "rbac-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "ENFORCED"
  },
  "cell": "rbac-cell",
  "status": "ACTIVE",
  "layer": "foundation_governance",
  "wave": 0,
  "governance_level": "IMMUTABLE_EXCEPT_GATEKEEPER"
}
### src/cells/kernel/security-cell/cell.manifest.json ###
{
  "constitutionalAdn": {
    "identity": "security-cell",
    "capability": [],
    "boundary": "strict",
    "trace": "audit",
    "confidence": 0.5,
    "smartlink": "event-bus",
    "lifecycle": "ENFORCED"
  },
  "cell": "security-cell",
  "status": "ACTIVE",
  "layer": "foundation_governance",
  "wave": 0,
  "governance_level": "IMMUTABLE_EXCEPT_GATEKEEPER"
}

--- 8. TSC ERROR COUNT ---
src/services/recovery-engine.ts(39,9): error TS2322: Type '"FAILED"' is not assignable to type '"PENDING" | "SUCCESS" | "FAILURE"'.
src/services/recovery-engine.ts(57,5): error TS2322: Type '"FAILED"' is not assignable to type '"PENDING" | "SUCCESS" | "FAILURE"'.
src/services/recovery-engine.ts(74,11): error TS2322: Type '"RECOVERED"' is not assignable to type '"PENDING" | "SUCCESS" | "FAILURE"'.
src/services/recovery-engine.ts(102,6): error TS2322: Type '"RECOVERED"' is not assignable to type '"PENDING" | "SUCCESS" | "FAILURE"'.
src/services/sales-core.ts(86,7): error TS2353: Object literal may only specify known properties, and 'shippingFee' does not exist in type 'OrderPricing'.
src/services/sales-service.ts(7,31): error TS2307: Cannot find module '@/cells/sales-cell/sales.service' or its corresponding type declarations.
src/services/tax-report-service.ts(19,7): error TS2353: Object literal may only specify known properties, and 'amount' does not exist in type '{ taxableIncome: number; standardRate: number; rate?: number; taxAmount: number; incentiveAmount: number; incentives?: Record<string, number>; finalTax: number; effectiveRate: number; }'.
src/types.ts(679,3): error TS2300: Duplicate identifier 'destination'.
src/types.ts(683,3): error TS2300: Duplicate identifier 'destination'.
src/types.ts(683,3): error TS2717: Subsequent property declarations must have the same type.  Property 'destination' must be of type 'string', but here has type 'any'.
